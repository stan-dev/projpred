<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>projpred: Projection predictive feature selection • projpred</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="projpred: Projection predictive feature selection">
<meta property="og:description" content="projpred">
<meta property="og:image" content="https://mc-stan.org/projpred/logo.svg">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">projpred</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">2.7.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Other Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="https://mc-stan.org/rstan" class="external-link">rstan</a>
    </li>
    <li>
      <a href="https://mc-stan.org/cmdstanr" class="external-link">cmdstanr</a>
    </li>
    <li>
      <a href="https://mc-stan.org/rstanarm" class="external-link">rstanarm</a>
    </li>
    <li>
      <a href="https://mc-stan.org/bayesplot" class="external-link">bayesplot</a>
    </li>
    <li>
      <a href="https://mc-stan.org/shinystan" class="external-link">shinystan</a>
    </li>
    <li>
      <a href="https://mc-stan.org/loo" class="external-link">loo</a>
    </li>
    <li>
      <a href="https://mc-stan.org/rstantools" class="external-link">rstantools</a>
    </li>
    <li>
      <a href="https://mc-stan.org/posterior" class="external-link">posterior</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://mc-stan.org" class="external-link">Stan</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://twitter.com/mcmc_stan" class="external-link">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/stan-dev/projpred/" class="external-link">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="https://discourse.mc-stan.org/" class="external-link">
    <span class="fa fa-users"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>projpred: Projection predictive feature
selection</h1>
            
            <h4 data-toc-skip class="date">2023-09-30</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/stan-dev/projpred/blob/HEAD/vignettes/projpred.Rmd" class="external-link"><code>vignettes/projpred.Rmd</code></a></small>
      <div class="hidden name"><code>projpred.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="intro">Introduction<a class="anchor" aria-label="anchor" href="#intro"></a>
</h2>
<p>This vignette illustrates the main functionalities of the
<strong>projpred</strong> package, which implements the projection
predictive variable selection for various regression models (see section
<a href="#modtypes">“Supported types of models”</a> below for more
details on supported model types). What is special about the projection
predictive variable selection is that it not only performs a variable
selection, but also allows for (approximately) valid post-selection
inference.</p>
<p>The projection predictive variable selection is based on the ideas of
<span class="citation">Goutis and Robert (<a href="#ref-goutis_model_1998">1998</a>)</span> and <span class="citation">Dupuis and Robert (<a href="#ref-dupuis_variable_2003">2003</a>)</span>. The methods
implemented in <strong>projpred</strong> are described in detail in
<span class="citation">Piironen, Paasiniemi, and Vehtari (<a href="#ref-piironen_projective_2020">2020</a>)</span>, <span class="citation">Catalina, Bürkner, and Vehtari (<a href="#ref-catalina_projection_2022">2022</a>)</span>, <span class="citation">Weber, Glass, and Vehtari (<a href="#ref-weber_projection_2023">2023</a>)</span>, and <span class="citation">Catalina, Bürkner, and Vehtari (<a href="#ref-catalina_latent_2021">2021</a>)</span>. A comparison to many
other methods may also be found in <span class="citation">Piironen and
Vehtari (<a href="#ref-piironen_comparison_2017">2017a</a>)</span>. For
details on how to cite <strong>projpred</strong>, see the <a href="https://CRAN.R-project.org/package=projpred/citation.html" class="external-link">projpred
citation info</a> on CRAN<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
</div>
<div class="section level2">
<h2 id="data">Data<a class="anchor" aria-label="anchor" href="#data"></a>
</h2>
<p>For this vignette, we use <strong>projpred</strong>’s
<code>df_gaussian</code> data. It contains 100 observations of 20
continuous predictor variables <code>X1</code>, …, <code>X20</code>
(originally stored in a sub-matrix; we turn them into separate columns
below) and one continuous response variable <code>y</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"df_gaussian"</span>, package <span class="op">=</span> <span class="st">"projpred"</span><span class="op">)</span></span>
<span><span class="va">dat_gauss</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">df_gaussian</span><span class="op">$</span><span class="va">y</span>, <span class="va">df_gaussian</span><span class="op">$</span><span class="va">x</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="refmod">Reference model<a class="anchor" aria-label="anchor" href="#refmod"></a>
</h2>
<p>First, we have to construct a reference model for the projection
predictive variable selection. This model is considered as the best
(“reference”) solution to the prediction task. The aim of the projection
predictive variable selection is to find a subset of a set of candidate
predictors which is as small as possible but achieves a predictive
performance as close as possible to that of the reference model.</p>
<p>Usually (and this is also the case in this vignette), the reference
model will be an <a href="https://mc-stan.org/rstanarm/" class="external-link"><strong>rstanarm</strong></a> or <a href="https://paul-buerkner.github.io/brms/" class="external-link"><strong>brms</strong></a>
fit. To our knowledge, <strong>rstanarm</strong> and
<strong>brms</strong> are currently the only packages for which a
<code><a href="../reference/refmodel-init-get.html">get_refmodel()</a></code> method (which establishes the compatibility
with <strong>projpred</strong>) exists. Creating a reference model
object via one of these methods <code><a href="../reference/refmodel-init-get.html">get_refmodel.stanreg()</a></code> or
<code><a href="https://paul-buerkner.github.io/brms/reference/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code> (either implicitly by a call
to a top-level function such as <code><a href="../reference/project.html">project()</a></code>,
<code><a href="../reference/varsel.html">varsel()</a></code>, and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>, as done below, or
explicitly by a call to <code><a href="../reference/refmodel-init-get.html">get_refmodel()</a></code>) leads to a
“typical” reference model object. In that case, all candidate models are
actual <em>sub</em>models of the reference model. In general, however,
this assumption is not necessary for a projection predictive variable
selection <span class="citation">(see, e.g., <a href="#ref-piironen_projective_2020">Piironen, Paasiniemi, and Vehtari
2020</a>)</span>. This is why “custom” (i.e., non-“typical”) reference
model objects allow to avoid this assumption (although the candidate
models of a “custom” reference model object will still be actual
<em>sub</em>models of the full <code>formula</code> used by the search
procedure—which does not have to be the same as the reference model’s
<code>formula</code>, if the reference model possesses a
<code>formula</code> at all). Such “custom” reference model objects can
be constructed via <code><a href="../reference/refmodel-init-get.html">init_refmodel()</a></code> (or
<code><a href="../reference/refmodel-init-get.html">get_refmodel.default()</a></code>), as shown in section “Examples” of
the <code><a href="../reference/refmodel-init-get.html">?init_refmodel</a></code> help<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>.</p>
<p>Here, we use the <strong>rstanarm</strong> package to fit the
reference model. If you want to use the <strong>brms</strong> package,
simply replace the <strong>rstanarm</strong> fit (of class
<code>stanreg</code>) in all the code below by your
<strong>brms</strong> fit (of class <code>brmsfit</code>).</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/rstanarm/" class="external-link">rstanarm</a></span><span class="op">)</span></span></code></pre></div>
<p>For our <strong>rstanarm</strong> reference model, we use the
Gaussian distribution as the <code>family</code> for our response. With
respect to the predictors, we only include the linear main effects of
all 20 predictor variables. Compared to the more complex types of
reference models supported by <strong>projpred</strong> (see section <a href="#modtypes">“Supported types of models”</a> below), this is a quite
simple reference model which is sufficient, however, to demonstrate the
interplay of <strong>projpred</strong>’s functions.</p>
<p>We use <strong>rstanarm</strong>’s default priors in our reference
model, except for the regression coefficients for which we use a
regularized horseshoe prior <span class="citation">(<a href="#ref-piironen_sparsity_2017">Piironen and Vehtari
2017c</a>)</span> with the hyperprior for its global shrinkage parameter
following <span class="citation">Piironen and Vehtari (<a href="#ref-piironen_hyperprior_2017">2017b</a>)</span> and <span class="citation">Piironen and Vehtari (<a href="#ref-piironen_sparsity_2017">2017c</a>)</span>. In R code, these
are the preparation steps for the regularized horseshoe prior:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Number of regression coefficients:</span></span>
<span><span class="op">(</span> <span class="va">D</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">grepl</a></span><span class="op">(</span><span class="st">"^X"</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">dat_gauss</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>[1] 20</code></pre>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Prior guess for the number of relevant (i.e., non-zero) regression</span></span>
<span><span class="co"># coefficients:</span></span>
<span><span class="va">p0</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="co"># Number of observations:</span></span>
<span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">dat_gauss</span><span class="op">)</span></span>
<span><span class="co"># Hyperprior scale for tau, the global shrinkage parameter (note that for the</span></span>
<span><span class="co"># Gaussian family, 'rstanarm' will automatically scale this by the residual</span></span>
<span><span class="co"># standard deviation):</span></span>
<span><span class="va">tau0</span> <span class="op">&lt;-</span> <span class="va">p0</span> <span class="op">/</span> <span class="op">(</span><span class="va">D</span> <span class="op">-</span> <span class="va">p0</span><span class="op">)</span> <span class="op">*</span> <span class="fl">1</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">N</span><span class="op">)</span></span></code></pre></div>
<p>We now fit the reference model to the data. To make this vignette
build faster, we use only 2 MCMC chains and 1000 iterations per chain
(with half of them being discarded as warmup draws). In practice, 4
chains and 2000 iterations per chain are reasonable defaults.
Furthermore, we make use of <a href="https://mc-stan.org/rstan/" class="external-link"><strong>rstan</strong></a>’s
parallelization, which means to run each chain on a separate CPU core<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>. If you
run the following code yourself, you can either rely on an automatic
mechanism to detect the number of CPU cores (like the
<code><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">parallel::detectCores()</a></code> function shown below) or adapt
<code>ncores</code> manually to your system.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Set this manually if desired:</span></span>
<span><span class="va">ncores</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">detectCores</a></span><span class="op">(</span>logical <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">### Only for technical reasons in this vignette (you can omit this when running</span></span>
<span><span class="co">### the code yourself):</span></span>
<span><span class="va">ncores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">ncores</span>, <span class="fl">2L</span><span class="op">)</span></span>
<span><span class="co">###</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>mc.cores <span class="op">=</span> <span class="va">ncores</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">507801</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_glm.html" class="external-link">stan_glm</a></span><span class="op">(</span></span>
<span>  <span class="va">y</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span> <span class="op">+</span> <span class="va">X10</span> <span class="op">+</span> <span class="va">X11</span> <span class="op">+</span> <span class="va">X12</span> <span class="op">+</span> <span class="va">X13</span> <span class="op">+</span> <span class="va">X14</span> <span class="op">+</span></span>
<span>    <span class="va">X15</span> <span class="op">+</span> <span class="va">X16</span> <span class="op">+</span> <span class="va">X17</span> <span class="op">+</span> <span class="va">X18</span> <span class="op">+</span> <span class="va">X19</span> <span class="op">+</span> <span class="va">X20</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">dat_gauss</span>,</span>
<span>  prior <span class="op">=</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/priors.html" class="external-link">hs</a></span><span class="op">(</span>global_scale <span class="op">=</span> <span class="va">tau0</span><span class="op">)</span>,</span>
<span>  <span class="co">### Only for the sake of speed (not recommended in general):</span></span>
<span>  chains <span class="op">=</span> <span class="fl">2</span>, iter <span class="op">=</span> <span class="fl">1000</span>,</span>
<span>  <span class="co">###</span></span>
<span>  QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#bulk-ess</code></pre>
<p>Usually, we would now have to check the convergence diagnostics (see,
e.g., <code><a href="https://mc-stan.org/posterior/reference/diagnostics.html" class="external-link">?posterior::diagnostics</a></code> and
<code><a href="https://mc-stan.org/posterior/reference/draws_summary.html" class="external-link">?posterior::default_convergence_measures</a></code>; the bulk-ESS
warning already indicates a problem). However, due to the technical
reasons for which we reduced <code>chains</code> and <code>iter</code>,
we skip this step here (and hence ignore the bulk-ESS warning).</p>
</div>
<div class="section level2">
<h2 id="variableselection">Variable selection<a class="anchor" aria-label="anchor" href="#variableselection"></a>
</h2>
<p>Now, <strong>projpred</strong> comes into play.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/projpred/">projpred</a></span><span class="op">)</span></span></code></pre></div>
<p>In <strong>projpred</strong>, the projection predictive variable
selection relies on a so-called <em>search</em> part and a so-called
<em>evaluation</em> part. The search part determines the predictor
ranking (also known as solution path), i.e., the best submodel for each
submodel size (the size is given by the number of predictor terms). The
evaluation part determines the predictive performance of the
increasingly complex submodels along the predictor ranking.</p>
<p>There are two functions for running the combination of search and
evaluation: <code><a href="../reference/varsel.html">varsel()</a></code> and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>. In
contrast to <code><a href="../reference/varsel.html">varsel()</a></code>, <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> performs a
cross-validation (CV). With <code>cv_method = "LOO"</code> (the
default), <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> runs a Pareto-smoothed importance
sampling leave-one-out CV <span class="citation">(PSIS-LOO CV, see <a href="#ref-vehtari_practical_2017">Vehtari, Gelman, and Gabry 2017</a>;
<a href="#ref-vehtari_pareto_2022">Vehtari et al. 2022</a>)</span>. With
<code>cv_method = "kfold"</code>, <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> runs a <span class="math inline">\(K\)</span>-fold CV. The extent of the CV depends
on <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>’s argument <code>validate_search</code>: If
<code>validate_search = TRUE</code> (the default), the search part is
run with the training data of each CV fold separately and the evaluation
part is run with the corresponding test data of each CV fold. If
<code>validate_search = FALSE</code> (which is currently only available
for <code>cv_method = "LOO"</code>), the search is excluded from the CV
so that only a single full-data search is run. Because of its most
thorough protection against overfitting<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>,
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with <code>validate_search = TRUE</code> is
recommended over <code><a href="../reference/varsel.html">varsel()</a></code> and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = FALSE</code>. Nonetheless, a preliminary and
comparatively fast run of <code><a href="../reference/varsel.html">varsel()</a></code> or
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with <code>validate_search = FALSE</code> can
give a rough idea of the performance of the submodels and can be used
for finding a suitable value for argument <code>nterms_max</code> in
subsequent runs (argument <code>nterms_max</code> imposes a limit on the
submodel size up to which the search is continued and is thus able to
reduce the runtime considerably).</p>
<p>To illustrate a preliminary <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> run with
<code>validate_search = FALSE</code>, we set <code>nterms_max</code> to
the number of predictor terms in the full model, i.e.,
<code>nterms_max = 20</code>. To speed up the building of the vignette
(this is not recommended in general), we choose the <code>"L1"</code>
search <code>method</code>
<!-- (in general, the default of forward search is more desirable, see `?varsel` or `?cv_varsel` for details) -->
and set <code>nclusters_pred</code> to a comparatively low value of
<code>20</code>.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Preliminary cv_varsel() run:</span></span>
<span><span class="va">cvvs_fast</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/cv_varsel.html">cv_varsel</a></span><span class="op">(</span></span>
<span>  <span class="va">refm_fit</span>,</span>
<span>  validate_search <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  <span class="co">### Only for the sake of speed (not recommended in general):</span></span>
<span>  method <span class="op">=</span> <span class="st">"L1"</span>,</span>
<span>  nclusters_pred <span class="op">=</span> <span class="fl">20</span>,</span>
<span>  <span class="co">###</span></span>
<span>  nterms_max <span class="op">=</span> <span class="fl">20</span>,</span>
<span>  <span class="co">### In interactive use, we recommend not to deactivate the verbose mode:</span></span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span>
<span>  <span class="co">### </span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>Warning: Some Pareto k diagnostic values are slightly high. See help('pareto-k-diagnostic') for details.</code></pre>
<pre><code>Warning in warn_pareto(n07 = sum(pareto_k &gt; 0.7), n05 = sum(0.7 &gt;= pareto_k &amp; :
In the calculation of the reference model's PSIS-LOO CV weights, 6 (out of 100)
Pareto k-values are in the interval (0.5, 0.7]. Moment matching (see the loo
package), mixture importance sampling (see the loo package), and `reloo`-ing
(see the brms package) are not supported by projpred. If these techniques (run
outside of projpred, i.e., for the reference model only; note that `reloo`-ing
may be computationally costly) result in a markedly different reference model
ELPD estimate than ordinary PSIS-LOO CV does, we recommend to use K-fold CV
within projpred.</code></pre>
<pre><code>Warning in loo_varsel(refmodel = refmodel, method = method, nterms_max =
nterms_max, : The projected draws used for the performance evaluation have
different (i.e., nonconstant) weights, so using standard importance sampling
(SIS) instead of Pareto-smoothed importance sampling (PSIS). In general, PSIS
is recommended over SIS.</code></pre>
<p>In this case, we ignore the Pareto <span class="math inline">\(\hat{k}\)</span> warnings due to the reduced
values for <code>chains</code> and <code>iter</code> in the reference
model fit. We also ignore the warning that SIS is used instead of PSIS
(this is due to <code>nclusters_pred = 20</code> which we used only to
speed up the building of the vignette).</p>
<p>To find a suitable value for <code>nterms_max</code> in subsequent
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> runs, we take a look at a plot of at least one
predictive performance statistic in dependence of the submodel size.
Here, we choose the mean log predictive density (MLPD; see the
documentation for argument <code>stats</code> of
<code><a href="../reference/summary.vsel.html">summary.vsel()</a></code> for details) as the only performance
statistic. Since we will be using the following plot only to determine
<code>nterms_max</code> for subsequent <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> runs, we
can omit the predictor ranking from the plot by setting
<code>ranking_nterms_max</code> to <code>NA</code>:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">cvvs_fast</span>, stats <span class="op">=</span> <span class="st">"mlpd"</span>, ranking_nterms_max <span class="op">=</span> <span class="cn">NA</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/plot_vsel_fast-1.png" width="90%" style="display: block; margin: auto;">
This plot (see <code><a href="../reference/plot.vsel.html">?plot.vsel</a></code> for a description) shows that the
submodel MLPD does not change much after submodel size 8, so in our
final <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> run, we set <code>nterms_max</code> to a
value slightly higher than 8 (here: <code>nterms_max = 9</code>) to
ensure that we see the MLPD leveling off.</p>
<p>For this final <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> run, we use a <span class="math inline">\(K\)</span>-fold CV with a small number of folds
(<code>K = 2</code>) to make this vignette build faster. In practice, we
recommend using either the default of <code>cv_method = "LOO"</code>
(with <code>validate_search = TRUE</code>) or a larger value for
<code>K</code> if this is possible in terms of computation time. We also
illustrate how <strong>projpred</strong>’s CV can be parallelized, even
though this is of little use here (we have only <code>K = 2</code> folds
and the fold-wise searches and performance evaluations are quite fast,
so the parallelization overhead eats up any runtime improvements).</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># For the CV parallelization (cv_varsel()'s argument `parallel`):</span></span>
<span><span class="fu">doParallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/doParallel/man/registerDoParallel.html" class="external-link">registerDoParallel</a></span><span class="op">(</span><span class="va">ncores</span><span class="op">)</span></span>
<span><span class="co"># Final cv_varsel() run:</span></span>
<span><span class="va">cvvs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/cv_varsel.html">cv_varsel</a></span><span class="op">(</span></span>
<span>  <span class="va">refm_fit</span>,</span>
<span>  cv_method <span class="op">=</span> <span class="st">"kfold"</span>,</span>
<span>  <span class="co">### Only for the sake of speed (not recommended in general):</span></span>
<span>  K <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  method <span class="op">=</span> <span class="st">"L1"</span>,</span>
<span>  nclusters_pred <span class="op">=</span> <span class="fl">20</span>,</span>
<span>  <span class="co">###</span></span>
<span>  nterms_max <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  parallel <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  <span class="co">### In interactive use, we recommend not to deactivate the verbose mode:</span></span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span>
<span>  <span class="co">### </span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code>Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#bulk-ess

Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
Running the chains for more iterations may help. See
https://mc-stan.org/misc/warnings.html#bulk-ess</code></pre>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Tear down the CV parallelization setup:</span></span>
<span><span class="fu">doParallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/doParallel/man/registerDoParallel.html" class="external-link">stopImplicitCluster</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu">foreach</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/foreach/man/registerDoSEQ.html" class="external-link">registerDoSEQ</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p>Again, we ignore the bulk-ESS warnings due to the reduced values for
<code>chains</code> and <code>iter</code> in the reference model
fit.</p>
<p>We can now select a final submodel size by looking at a predictive
performance plot similar to the one created for the preliminary
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> run above. By default, the performance
statistics are plotted on their original scale, but with
<code>deltas = TRUE</code>, they are plotted as differences from a
baseline model (which is the reference model by default, at least in the
most common cases). Since the differences and the (frequentist)
uncertainty in their estimation are usually of more interest than the
original-scale performance statistics (at least with regard to the
decision for a final submodel size), we directly plot with
<code>deltas = TRUE</code> here:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">cvvs</span>, stats <span class="op">=</span> <span class="st">"mlpd"</span>, deltas <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/plot_vsel-1.png" width="90%" style="display: block; margin: auto;"></p>
<p>Based on that plot, we decide for a submodel size. Usually, the aim
is to find the smallest submodel size where the predictive performance
of the submodels levels off and is close enough to the reference model’s
predictive performance (the dashed red horizontal line). Sometimes (as
here), the plot may be ambiguous because after reaching the reference
model’s performance, the submodels’ performance may keep increasing (and
hence become even better than the reference model’s performance<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>). In that
case, one has to find a suitable trade-off between predictive
performance (accuracy) and model size (sparsity) in the context of
subject-matter knowledge. Here, we assume that the focus of our
predictive model is sparsity (not accuracy). Hence, based on the plot,
we decide for a submodel size of 6 because this is the smallest size
where the submodel MLPD is close enough to the reference model MLPD:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">size_decided</span> <span class="op">&lt;-</span> <span class="fl">6</span></span></code></pre></div>
<p>If the focus of our predictive model had been accuracy (not
sparsity), size 8 would have been a natural choice because at size 8,
the submodel MLPD “levels off” (in fact, size 8 here even comes with the
maximum submodel MLPD among all plotted sizes, but in general, this does
not need to be the case). Further below, the predictor ranking and the
(CV) ranking proportions that are shown in the plot (below the submodel
sizes on the x-axis) are explained in detail—and also how they could
have been incorporated into our decision for a submodel size.</p>
<p>The <code><a href="../reference/suggest_size.html">suggest_size()</a></code> function offered by
<strong>projpred</strong> may help in the decision for a submodel size,
but this is a rather heuristic method and needs to be interpreted with
caution (see <code><a href="../reference/suggest_size.html">?suggest_size</a></code>):</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/suggest_size.html">suggest_size</a></span><span class="op">(</span><span class="va">cvvs</span>, stat <span class="op">=</span> <span class="st">"mlpd"</span><span class="op">)</span></span></code></pre></div>
<pre><code>[1] 6</code></pre>
<p>With this heuristic, we would get the same final submodel size
(<code>6</code>) as by our manual (sparsity-based) decision.</p>
<p>A tabular representation of the plot created by
<code><a href="../reference/plot.vsel.html">plot.vsel()</a></code> can be achieved via
<code><a href="../reference/summary.vsel.html">summary.vsel()</a></code>. For the output of
<code><a href="../reference/summary.vsel.html">summary.vsel()</a></code>, there is a sophisticated
<code><a href="https://rdrr.io/r/base/print.html" class="external-link">print()</a></code> method (<code><a href="../reference/print.vselsummary.html">print.vselsummary()</a></code>) which is
also called by the shortcut method <code><a href="../reference/print.vsel.html">print.vsel()</a></code><a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>.
Specifically, to create the summary table matching the predictive
performance plot above as closely as possible (and to also adjust the
minimum number of printed significant digits), we may call
<code><a href="../reference/summary.vsel.html">summary.vsel()</a></code> and <code><a href="../reference/print.vselsummary.html">print.vselsummary()</a></code> as
follows:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">smmry</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">cvvs</span>, stats <span class="op">=</span> <span class="st">"mlpd"</span>, type <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"mean"</span>, <span class="st">"lower"</span>, <span class="st">"upper"</span><span class="op">)</span>,</span>
<span>                 deltas <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">smmry</span>, digits <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code>
Family: gaussian 
Link function: identity 

Formula: y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10 + X11 + 
    X12 + X13 + X14 + X15 + X16 + X17 + X18 + X19 + X20
Observations: 100
Projection method: traditional
CV method: K-fold CV with K = 2 and search included (i.e., fold-wise searches)
Search method: L1
Maximum submodel size for the search: 9
Number of projected draws in the search: 1 (from clustered projection)
Number of projected draws in the performance evaluation: 20 (from clustered projection)

Performance evaluation summary with `deltas = TRUE` and `cumulate = FALSE`:
 size solution_terms cv_proportions_diag mlpd.kfold lower upper
    0           &lt;NA&gt;                  NA      -0.92 -1.01 -0.83
    1             X1                 1.0      -0.70 -0.79 -0.61
    2            X14                 1.0      -0.57 -0.66 -0.48
    3             X5                 0.5      -0.52 -0.63 -0.41
    4            X20                 1.0      -0.33 -0.42 -0.24
    5             X6                 0.0      -0.16 -0.25 -0.08
    6             X3                 0.0       0.05 -0.01  0.12
    7             X8                 0.5       0.08  0.04  0.12
    8            X11                 0.0       0.11  0.07  0.14
    9            X10                 0.0       0.09  0.06  0.13</code></pre>
<pre><code>Column `solution_terms` contains the full-data predictor ranking. To retrieve the fold-wise predictor rankings, use the ranking() function, possibly followed by cv_proportions() for computing the ranking proportions (which can be visualized by plot.cv_proportions()). The main diagonal of the matrix returned by cv_proportions() (with `cumulate = FALSE`) is contained in column `cv_proportions_diag`.</code></pre>
<p>As highlighted by the message above, the predictor ranking from
column <code>solution_terms</code> is based on the full-data search. In
case of <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = TRUE</code>, there is not only the full-data
search, but also fold-wise searches, implying that there are also
fold-wise predictor rankings. All of these predictor rankings (the
full-data one and—if available—the fold-wise ones) can be retrieved via
<code><a href="../reference/ranking.html">ranking()</a></code>:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ranking.html">ranking</a></span><span class="op">(</span><span class="va">cvvs</span><span class="op">)</span></span></code></pre></div>
<p>In addition to inspecting the full-data predictor ranking, it usually
makes sense to investigate the ranking proportions derived from the
fold-wise predictor rankings (only available in case of
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with <code>validate_search = TRUE</code>, which
we have here) in order to get a sense for the variability in the ranking
of the predictors. For a given predictor <span class="math inline">\(x\)</span> and a given submodel size <span class="math inline">\(j\)</span>, the ranking proportion is the
proportion of CV folds which have predictor <span class="math inline">\(x\)</span> at position <span class="math inline">\(j\)</span> of their predictor ranking. To compute
these ranking proportions, we use <code><a href="../reference/cv_proportions.html">cv_proportions()</a></code>:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">pr_rk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/cv_proportions.html">cv_proportions</a></span><span class="op">(</span><span class="va">rk</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>    predictor
size X1 X14  X5 X20  X6 X3  X8 X11 X10
   1  1   0 0.0   0 0.0  0 0.0 0.0   0
   2  0   1 0.0   0 0.0  0 0.0 0.0   0
   3  0   0 0.5   0 0.5  0 0.0 0.0   0
   4  0   0 0.0   1 0.0  0 0.0 0.0   0
   5  0   0 0.0   0 0.0  1 0.0 0.0   0
   6  0   0 0.5   0 0.5  0 0.0 0.0   0
   7  0   0 0.0   0 0.0  0 0.5 0.5   0
   8  0   0 0.0   0 0.0  0 0.5 0.0   0
   9  0   0 0.0   0 0.0  0 0.0 0.5   0
attr(,"class")
[1] "cv_proportions"</code></pre>
<p>Here, the ranking proportions are of little use as we have used
<code>K = 2</code> (in the final <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> call above)
for the sake of speed. Nevertheless, we can see that the two CV folds
agree on the set of the two most relevant predictor terms
(<code>X1</code> and <code>X14</code>) as well as on their order. Since
the column names of the matrix returned by <code><a href="../reference/cv_proportions.html">cv_proportions()</a></code>
follow the full-data predictor ranking, we can infer that
<code>X1</code> and <code>X14</code> are also the two most relevant
predictor terms in the full-data predictor ranking. To see this more
explicitly, we can access element <code>fulldata</code> of the
<code><a href="../reference/ranking.html">ranking()</a></code> output:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rk</span><span class="op">[[</span><span class="st">"fulldata"</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<pre><code>[1] "X1"  "X14" "X5"  "X20" "X6"  "X3"  "X8"  "X11" "X10"</code></pre>
<p>This is the same as column <code>solution_terms</code> in the
<code><a href="../reference/summary.vsel.html">summary.vsel()</a></code> output above. (As also stated by the message
thrown by <code><a href="../reference/print.vselsummary.html">print.vselsummary()</a></code>, column
<code>cv_proportions_diag</code> of the <code><a href="../reference/summary.vsel.html">summary.vsel()</a></code>
output contains the main diagonal of the matrix that we stored manually
as <code>pr_rk</code>.)</p>
<p>Note that we have cut off the search at <code>nterms_max = 9</code>
(which is smaller than the number of predictor terms in the full model,
20 here), so the ranking proportions in the <code>pr_rk</code> matrix do
not need to sum to 100 % (neither column-wise nor row-wise).</p>
<p>The <em>transposed</em> matrix of ranking proportions can be
visualized via <code><a href="../reference/plot.cv_proportions.html">plot.cv_proportions()</a></code>:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">pr_rk</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/plot_cv_proportions-1.png" width="90%" style="display: block; margin: auto;">
Apart from visualizing the variability in the ranking of the predictors
(here, this is of little use because of <code>K = 2</code>), this plot
will be helpful later.</p>
<p>To retrieve the predictor terms of the final submodel (except for the
intercept which is always included in the submodels), we combine the
chosen submodel size of 6 with the full-data predictor ranking:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">predictors_final</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">rk</span><span class="op">[[</span><span class="st">"fulldata"</span><span class="op">]</span><span class="op">]</span>, <span class="va">size_decided</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>[1] "X1"  "X14" "X5"  "X20" "X6"  "X3" </code></pre>
<p>At this place, it is again helpful to take the ranking proportions
into account, but now in a cumulated fashion:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="fu"><a href="../reference/cv_proportions.html">cv_proportions</a></span><span class="op">(</span><span class="va">rk</span>, cumulate <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/plot_cv_proportions_cumul-1.png" width="90%" style="display: block; margin: auto;">
This plot confirms (from a slightly different perspective) that the two
fold-wise searches (as well as the full-data search, whose predictor
ranking determines the order of the predictors on the y-axis) agree on
the <em>set</em> of the two most relevant predictors (<code>X1</code>
and <code>X14</code>): When looking at <code>&lt;=2</code> on the
x-axis, all tiles above and including the second main diagonal element
are at 100 %. Similarly, the two CV folds agree on the <em>sets</em> of
the six and nine most relevant predictors (and also on the set of the
most relevant predictor, which is a singleton).
<!-- Looking at `<=6` on the x-axis, we see that for our chosen submodel size of 6, both CV folds have most terms from `predictors_final` included among the first 6 terms of their predictor ranking, except for `X6`. -->
<!-- Only one of the two CV folds includes `X6` among the first 6 terms, but the other CV fold includes it shortly after that (at size 7, see also the `plot(pr_rk)` call above), which indicates that `X6` might indeed be a helpful term. --></p>
<p>Although not demonstrated here, the cumulated ranking proportions
could also have guided the decision for a submodel size (if we had not
been willing to follow a strict rule based on accuracy or sparsity):
From their plot, we can see that size 9 might have been an unfortunate
choice because <code>X10</code> (which—by cutting off the full-data
predictor ranking at size 9—would then have been selected as the ninth
predictor in the final submodel) is not included among the first 9 terms
by any CV fold. However, since <code>K = 2</code> is too small for
reliable statements regarding the variability of the predictor ranking,
we did not take the cumulated ranking proportions into account when we
made our decision for a submodel size above.</p>
<p>In a real-world application, we might also be able to incorporate the
full-data predictor ranking into our decision for a submodel size
(usually, this requires to also take into account the variability of the
predictor ranking, as reflected by the—possibly cumulated—ranking
proportions). For example, the predictors might be associated with
different measurement costs, so that we might want to select a costly
predictor only if the submodel size at which it would be selected
(according to the full-data predictor ranking, but taking into account
that there might be variability in the ranking of the predictors) comes
with a considerable increase in predictive performance.</p>
</div>
<div class="section level2">
<h2 id="post-selection-inference">Post-selection inference<a class="anchor" aria-label="anchor" href="#post-selection-inference"></a>
</h2>
<p>The <code><a href="../reference/project.html">project()</a></code> function returns an object of class
<code>projection</code> which forms the basis for convenient
post-selection inference. By the following <code><a href="../reference/project.html">project()</a></code> call,
we project the reference model onto the final submodel once again<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>:
<!-- In versions > 2.0.2, **projpred** offers a parallelization of the projection. -->
<!-- Typically, this only makes sense for a large number of projected draws. -->
<!-- Therefore, this parallelization is not activated by a simple logical switch, but by a threshold for the number of projected draws below which no parallelization will be used. -->
<!-- Values greater than or equal to this threshold will trigger the parallelization. -->
<!-- For more information, see the general package documentation available at ``?`projpred-package` ``. -->
<!-- There, we also explain why we are not running the parallelization on Windows and why we cannot recommend the parallelization of the projection for some types of reference models (see also section ["Supported types of models"](#modtypes) below). -->
<!-- ```{r prll_prj_prep} -->
<!-- if (!identical(.Platform$OS.type, "windows")) { -->
<!--   doParallel::registerDoParallel(ncores) -->
<!--   trigger_default <- options(projpred.prll_prj_trigger = 200) -->
<!-- } --> <!-- ``` --></p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/project.html">project</a></span><span class="op">(</span></span>
<span>  <span class="va">refm_fit</span>,</span>
<span>  solution_terms <span class="op">=</span> <span class="va">predictors_final</span>,</span>
<span>  <span class="co">### In interactive use, we recommend not to deactivate the verbose mode:</span></span>
<span>  verbose <span class="op">=</span> <span class="cn">FALSE</span></span>
<span>  <span class="co">###</span></span>
<span><span class="op">)</span></span></code></pre></div>
<!-- ```{r prll_prj_tear} -->
<!-- if (!identical(.Platform$OS.type, "windows")) { -->
<!--   options(trigger_default) -->
<!--   doParallel::stopImplicitCluster() -->
<!--   foreach::registerDoSEQ() -->
<!-- } -->
<!-- ``` -->
<p>Next, we create a matrix containing the projected posterior draws
stored in the depths of <code><a href="../reference/project.html">project()</a></code>’s output:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">prj</span><span class="op">)</span></span></code></pre></div>
<p>This matrix is all we need for post-selection inference. It can be
used like any matrix of draws from MCMC procedures, except that it
doesn’t reflect a typical posterior distribution, but rather a projected
posterior distribution, i.e., the distribution arising from the
deterministic projection of the reference model’s posterior distribution
onto the parameter space of the final submodel<a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a>. Beware that in case
of clustered projection (i.e., a non-<code>NULL</code> argument
<code>nclusters</code> in the <code><a href="../reference/project.html">project()</a></code> call), the
projected draws have different (i.e., nonconstant) weights, which needs
to be taken into account when performing post-selection (or, more
generally, post-projection) inference, see
<code><a href="../reference/as_draws_matrix.projection.html">as_draws_matrix.projection()</a></code> (<code><a href="../reference/pred-projection.html">proj_linpred()</a></code>
and <code><a href="../reference/pred-projection.html">proj_predict()</a></code> offer similar functionality via
arguments <code>return_draws_matrix</code> and
<code>nresample_clusters</code>, respectively<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>).</p>
<div class="section level3">
<h3 id="marginals-of-the-projected-posterior">Marginals of the projected posterior<a class="anchor" aria-label="anchor" href="#marginals-of-the-projected-posterior"></a>
</h3>
<p>The <a href="https://mc-stan.org/posterior/" class="external-link"><strong>posterior</strong></a>
package provides a general way to deal with posterior distributions, so
it can also be applied to our projected posterior. For example, to
calculate summary statistics for the marginals of the projected
posterior:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/posterior/" class="external-link">posterior</a></span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj_drws</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/posterior/reference/draws_matrix.html" class="external-link">as_draws_matrix</a></span><span class="op">(</span><span class="va">prj_mat</span><span class="op">)</span></span>
<span><span class="va">prj_smmry</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/posterior/reference/draws_summary.html" class="external-link">summarize_draws</a></span><span class="op">(</span></span>
<span>  <span class="va">prj_drws</span>,</span>
<span>  <span class="st">"median"</span>, <span class="st">"mad"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="va">x</span>, probs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.025</span>, <span class="fl">0.975</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="co"># Coerce to a `data.frame` because pkgdown versions &gt; 1.6.1 don't print the</span></span>
<span><span class="co"># tibble correctly:</span></span>
<span><span class="va">prj_smmry</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="va">prj_smmry</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">prj_smmry</span>, digits <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<pre><code>     variable median  mad 2.5% 97.5%
1 (Intercept)   0.03 0.09 -0.2   0.2
2          X1   1.38 0.10  1.2   1.6
3         X14  -1.12 0.09 -1.3  -0.9
4          X5  -0.92 0.10 -1.1  -0.7
5         X20  -1.12 0.11 -1.4  -0.9
6          X6   0.54 0.09  0.4   0.7
7          X3   0.78 0.10  0.6   1.0
8       sigma   1.14 0.08  1.0   1.3</code></pre>
<p>A visualization of the projected posterior can be achieved with the
<a href="https://mc-stan.org/bayesplot/" class="external-link"><strong>bayesplot</strong></a>
package, for example using its <code><a href="https://mc-stan.org/bayesplot/reference/MCMC-intervals.html" class="external-link">mcmc_intervals()</a></code>
function:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/bayesplot/" class="external-link">bayesplot</a></span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/bayesplot_theme_get.html" class="external-link">bayesplot_theme_set</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html" class="external-link">theme_bw</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/MCMC-intervals.html" class="external-link">mcmc_intervals</a></span><span class="op">(</span><span class="va">prj_mat</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/coord_cartesian.html" class="external-link">coord_cartesian</a></span><span class="op">(</span>xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.6</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/bayesplot_prj-1.png" width="90%" style="display: block; margin: auto;"></p>
<p>Note that we only visualize the <em>1-dimensional</em> marginals of
the projected posterior here. To gain a more complete picture, we would
have to visualize at least some <em>2-dimensional</em> marginals of the
projected posterior (i.e., marginals for pairs of parameters).</p>
<p>For comparison, consider the marginal posteriors of the corresponding
parameters in the reference model:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">refm_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">refm_fit</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/MCMC-intervals.html" class="external-link">mcmc_intervals</a></span><span class="op">(</span><span class="va">refm_mat</span>, pars <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">prj_mat</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/coord_cartesian.html" class="external-link">coord_cartesian</a></span><span class="op">(</span>xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.6</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/bayesplot_ref-1.png" width="90%" style="display: block; margin: auto;"></p>
<p>Here, the reference model’s marginal posteriors differ only slightly
from the marginals of the projected posterior. This does not necessarily
have to be the case.</p>
</div>
<div class="section level3">
<h3 id="predictions">Predictions<a class="anchor" aria-label="anchor" href="#predictions"></a>
</h3>
<p>Predictions from the final submodel can be made by
<code><a href="../reference/pred-projection.html">proj_linpred()</a></code> and <code><a href="../reference/pred-projection.html">proj_predict()</a></code>.</p>
<p>We start with <code><a href="../reference/pred-projection.html">proj_linpred()</a></code>. For example, suppose we
have the following new observations:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">dat_gauss_new</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/setNames.html" class="external-link">setNames</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">replicate</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">predictors_final</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  <span class="va">predictors_final</span></span>
<span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>  X1 X14 X5 X20 X6 X3
1 -1  -1 -1  -1 -1 -1
2  0   0  0   0  0  0
3  1   1  1   1  1  1</code></pre>
<p>Then <code><a href="../reference/pred-projection.html">proj_linpred()</a></code> can calculate the linear
predictors<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a> for all new observations from
<code>dat_gauss_new</code>. Depending on argument
<code>integrated</code>, these linear predictors can be averaged across
the projected draws (within each new observation). For instance, the
following computes the expected values of the new observations’
predictive distributions (beware that the following code refers to the
Gaussian family with the identity link function; for other
families—which usually come in combination with a different link
function—one would typically have to use <code>transform = TRUE</code>
in order to achieve such expected values):</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj_linpred</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pred-projection.html">proj_linpred</a></span><span class="op">(</span><span class="va">prj</span>, newdata <span class="op">=</span> <span class="va">dat_gauss_new</span>, integrated <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">dat_gauss_new</span>, linpred <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">prj_linpred</span><span class="op">$</span><span class="va">pred</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>  X1 X14 X5 X20 X6 X3     linpred
1 -1  -1 -1  -1 -1 -1  0.49546584
2  0   0  0   0  0  0  0.04249252
3  1   1  1   1  1  1 -0.41048080</code></pre>
<p>If <code>dat_gauss_new</code> also contained response values (i.e.,
<code>y</code> values in this example), then <code><a href="../reference/pred-projection.html">proj_linpred()</a></code>
would also evaluate the log predictive density at these (conditional on
each of the projected parameter draws if <code>integrated = FALSE</code>
and integrated over the projected parameter draws—before taking the
logarithm—if <code>integrated = TRUE</code>).</p>
<p>With <code><a href="../reference/pred-projection.html">proj_predict()</a></code>, we can obtain draws from predictive
distributions based on the final submodel. In contrast to
<code>proj_linpred(&lt;...&gt;, integrated = FALSE)</code>, this
encompasses not only the uncertainty arising from parameter estimation,
but also the uncertainty arising from the observation (or “sampling”)
model for the response<a href="#fn11" class="footnote-ref" id="fnref11"><sup>11</sup></a>. This is useful for what is usually
termed a posterior predictive check (PPC), but would have to be termed
something like a posterior-projection predictive check (PPPC) here:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj_predict</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pred-projection.html">proj_predict</a></span><span class="op">(</span><span class="va">prj</span><span class="op">)</span></span>
<span><span class="co"># Using the 'bayesplot' package:</span></span>
<span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/PPC-distributions.html" class="external-link">ppc_dens_overlay</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">dat_gauss</span><span class="op">$</span><span class="va">y</span>, yrep <span class="op">=</span> <span class="va">prj_predict</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/proj_predict-1.png" width="90%" style="display: block; margin: auto;"></p>
<p>This PPPC shows that our final projection is able to generate
predictions similar to the observed response values, which indicates
that this model is reasonable, at least in this regard.</p>
</div>
</div>
<div class="section level2">
<h2 id="modtypes">Supported types of models<a class="anchor" aria-label="anchor" href="#modtypes"></a>
</h2>
<p>In principle, the projection predictive variable selection requires
only little information about the form of the reference model. Although
many aspects of the reference model coincide with those from the
submodels if a “typical” reference model object is used, this does not
need to be the case if a “custom” reference model object is used (see
section <a href="#refmod">“Reference model”</a> above for the definition
of “typical” and “custom” reference model objects). This explains why in
general, the following remarks refer to the submodels and not to the
reference model.</p>
<p>In the following and throughout <strong>projpred</strong>’s
documentation, the term “traditional projection” is used whenever the
projection type is neither “augmented-data” nor “latent” (see below for
a description of these).</p>
<p>Apart from the <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian()</a></code> response family used in this
vignette, <strong>projpred</strong>’s traditional projection also
supports the <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code><a href="#fn12" class="footnote-ref" id="fnref12"><sup>12</sup></a> and the <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code>
family.</p>
<p>The families supported by <strong>projpred</strong>’s augmented-data
projection <span class="citation">(<a href="#ref-weber_projection_2023">Weber, Glass, and Vehtari
2023</a>)</span> are <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code><a href="#fn13" class="footnote-ref" id="fnref13"><sup>13</sup></a> <a href="#fn14" class="footnote-ref" id="fnref14"><sup>14</sup></a>,
<code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::cumulative()</a></code>, <code><a href="https://mc-stan.org/rstanarm/reference/stan_polr.html" class="external-link">rstanarm::stan_polr()</a></code>
fits, and <code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::categorical()</a></code><a href="#fn15" class="footnote-ref" id="fnref15"><sup>15</sup></a> <a href="#fn16" class="footnote-ref" id="fnref16"><sup>16</sup></a>. See
<code><a href="../reference/extend_family.html">?extend_family</a></code> (which is called by
<code><a href="../reference/refmodel-init-get.html">init_refmodel()</a></code>) for an explanation how to apply the
augmented-data projection to “custom” reference model objects. For
“typical” reference model objects (i.e., those created by
<code><a href="../reference/refmodel-init-get.html">get_refmodel.stanreg()</a></code> or
<code><a href="https://paul-buerkner.github.io/brms/reference/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code>), the augmented-data
projection is applied automatically if the family is supported by the
augmented-data projection and neither <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code> nor
<code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::bernoulli()</a></code>. For applying the augmented-data
projection to the <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code> (or
<code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::bernoulli()</a></code>) family, see <code><a href="../reference/extend_family.html">?extend_family</a></code>
as well as <code><a href="../reference/augdat_link_binom.html">?augdat_link_binom</a></code> and
<code><a href="../reference/augdat_ilink_binom.html">?augdat_ilink_binom</a></code>. Finally, we note that there are some
restrictions with respect to the augmented-data projection;
<strong>projpred</strong> will throw an informative error if a requested
feature is currently not supported for the augmented-data
projection.</p>
<p>The latent projection <span class="citation">(<a href="#ref-catalina_latent_2021">Catalina, Bürkner, and Vehtari
2021</a>)</span> is a quite general principle for extending
<strong>projpred</strong>’s traditional projection to more response
families. The latent projection is applied when setting argument
<code>latent</code> of <code><a href="../reference/extend_family.html">extend_family()</a></code> (which is called by
<code><a href="../reference/refmodel-init-get.html">init_refmodel()</a></code>) to <code>TRUE</code>. The families for
which full latent-projection functionality (in particular,
<code>resp_oscale = TRUE</code>, i.e., post-processing on the original
response scale) is currently available are <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code><a href="#fn17" class="footnote-ref" id="fnref17"><sup>17</sup></a> <a href="#fn18" class="footnote-ref" id="fnref18"><sup>18</sup></a>,
<code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code>, <code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::cumulative()</a></code>, and
<code><a href="https://mc-stan.org/rstanarm/reference/stan_polr.html" class="external-link">rstanarm::stan_polr()</a></code> fits<a href="#fn19" class="footnote-ref" id="fnref19"><sup>19</sup></a>. For all other
families, you can try to use the latent projection (by setting
<code>latent = TRUE</code>) and <strong>projpred</strong> should tell
you if any features are not available and how to make them available.
More details concerning the latent projection are given in the
corresponding <a href="https://mc-stan.org/projpred/articles/latent.html">latent-projection
vignette</a>. Note that there are some restrictions with respect to the
latent projection; <strong>projpred</strong> will throw an informative
error if a requested feature is currently not supported for the latent
projection.</p>
<p>On the side of the predictors, <strong>projpred</strong> not only
supports linear main effects as shown in this vignette, but also
interactions, multilevel<a href="#fn20" class="footnote-ref" id="fnref20"><sup>20</sup></a>, and—as an experimental
feature—additive<a href="#fn21" class="footnote-ref" id="fnref21"><sup>21</sup></a> terms.</p>
<p>Transferring this vignette to such more complex problems is
straightforward (also because this vignette employs a “typical”
reference model object): Basically, only the code for fitting the
reference model via <strong>rstanarm</strong> or <strong>brms</strong>
needs to be adapted. The <strong>projpred</strong> code stays almost the
same. Only note that in case of multilevel or additive reference models,
<!-- the parallelization of the projection is not recommended and that -->
some <strong>projpred</strong> functions then have slightly different
options for a few arguments. See the documentation for details.</p>
<p>For example, to apply <strong>projpred</strong> to the
<code>VerbAgg</code> dataset from the <a href="https://CRAN.R-project.org/package=lme4" class="external-link"><strong>lme4</strong></a>
package, a corresponding multilevel reference model for the binary
response <code>r2</code> could be created by the following code:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"VerbAgg"</span>, package <span class="op">=</span> <span class="st">"lme4"</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_glmer.html" class="external-link">stan_glmer</a></span><span class="op">(</span></span>
<span>  <span class="va">r2</span> <span class="op">~</span> <span class="va">btype</span> <span class="op">+</span> <span class="va">situ</span> <span class="op">+</span> <span class="va">mode</span> <span class="op">+</span> <span class="op">(</span><span class="va">btype</span> <span class="op">+</span> <span class="va">situ</span> <span class="op">+</span> <span class="va">mode</span> <span class="op">|</span> <span class="va">id</span><span class="op">)</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">VerbAgg</span>,</span>
<span>  QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>As an example for an additive (non-multilevel) reference model,
consider the <code>lasrosas.corn</code> dataset from the <a href="https://kwstat.github.io/agridat/" class="external-link"><strong>agridat</strong></a>
package. A corresponding reference model for the continuous response
<code>yield</code> could be created by the following code (note that
<code>pp_check(refm_fit)</code> gives a bad PPC in this case, so there’s
still room for improvement):</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"lasrosas.corn"</span>, package <span class="op">=</span> <span class="st">"agridat"</span><span class="op">)</span></span>
<span><span class="co"># Convert `year` to a `factor` (this could also be solved by using</span></span>
<span><span class="co"># `factor(year)` in the formula, but we avoid that here to put more emphasis on</span></span>
<span><span class="co"># the demonstration of the smooth term):</span></span>
<span><span class="va">lasrosas.corn</span><span class="op">$</span><span class="va">year</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">as.factor</a></span><span class="op">(</span><span class="va">lasrosas.corn</span><span class="op">$</span><span class="va">year</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_gamm4.html" class="external-link">stan_gamm4</a></span><span class="op">(</span></span>
<span>  <span class="va">yield</span> <span class="op">~</span> <span class="va">year</span> <span class="op">+</span> <span class="va">topo</span> <span class="op">+</span> <span class="fu">t2</span><span class="op">(</span><span class="va">nitro</span>, <span class="va">bv</span><span class="op">)</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">lasrosas.corn</span>,</span>
<span>  QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>As an example for an additive multilevel reference model, consider
the <code>gumpertz.pepper</code> dataset from the
<strong>agridat</strong> package. A corresponding reference model for
the binary response <code>disease</code> could be created by the
following code:</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"gumpertz.pepper"</span>, package <span class="op">=</span> <span class="st">"agridat"</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_gamm4.html" class="external-link">stan_gamm4</a></span><span class="op">(</span></span>
<span>  <span class="va">disease</span> <span class="op">~</span> <span class="va">field</span> <span class="op">+</span> <span class="va">leaf</span> <span class="op">+</span> <span class="fu">s</span><span class="op">(</span><span class="va">water</span><span class="op">)</span>,</span>
<span>  random <span class="op">=</span> <span class="op">~</span> <span class="op">(</span><span class="fl">1</span> <span class="op">|</span> <span class="va">row</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span> <span class="op">|</span> <span class="va">quadrat</span><span class="op">)</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">gumpertz.pepper</span>,</span>
<span>  QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>In case of multilevel models (currently only non-additive ones),
<strong>projpred</strong> has two global options that may be relevant
for users: <code>projpred.mlvl_pred_new</code> and
<code>projpred.mlvl_proj_ref_new</code>. These are explained in detail
in the general package documentation (available <a href="https://mc-stan.org/projpred/reference/projpred-package.html">online</a>
or by typing <code><a href="../reference/projpred-package.html">?`projpred-package`</a></code>).</p>
</div>
<div class="section level2">
<h2 id="troubleshooting">Troubleshooting<a class="anchor" aria-label="anchor" href="#troubleshooting"></a>
</h2>
<div class="section level3">
<h3 id="non-convergence-of-predictive-performance">Non-convergence of predictive performance<a class="anchor" aria-label="anchor" href="#non-convergence-of-predictive-performance"></a>
</h3>
<p>Sometimes, the predictor ranking makes sense, but for an increasing
submodel size, the predictive performance of the submodels does not
approach the reference model’s predictive performance so that the
submodels exhibit a predictive performance that stays worse than the
reference model’s. There are different reasons that can explain this
behavior (the following list might not be exhaustive, though):</p>
<ol style="list-style-type: decimal">
<li>The reference model’s posterior may be so wide that the default
<code>ndraws_pred</code> could be too small. Usually, this comes in
combination with a difference in predictive performance which is
comparatively small. Increasing <code>ndraws_pred</code> should help,
but it also increases the computational cost. Re-fitting the reference
model and thereby ensuring a narrower posterior (usually by employing a
stronger sparsifying prior) should have a similar effect.</li>
<li>For non-Gaussian models, the discrepancy may be due to the fact that
the penalized iteratively reweighted least squares (PIRLS) algorithm
might have convergence issues <span class="citation">(<a href="#ref-catalina_latent_2021">Catalina, Bürkner, and Vehtari
2021</a>)</span>. In this case, the latent-space approach by <span class="citation">Catalina, Bürkner, and Vehtari (<a href="#ref-catalina_latent_2021">2021</a>)</span> might help, see also
the latent-projection vignette linked above.</li>
</ol>
</div>
<div class="section level3">
<h3 id="overfitting">Overfitting<a class="anchor" aria-label="anchor" href="#overfitting"></a>
</h3>
<p>If you are using <code><a href="../reference/varsel.html">varsel()</a></code>, then the lack of CV in
<code><a href="../reference/varsel.html">varsel()</a></code> may lead to overconfident and overfitted results.
In this case, try running <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> instead of
<code><a href="../reference/varsel.html">varsel()</a></code> (which you should in any case for your final
results).</p>
<p>Similarly, <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = FALSE</code> is more prone to overfitting than
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with <code>validate_search = TRUE</code>.</p>
</div>
<div class="section level3">
<h3 id="issues-with-the-traditional-projection">Issues with the traditional projection<a class="anchor" aria-label="anchor" href="#issues-with-the-traditional-projection"></a>
</h3>
<p>For multilevel binomial models, the traditional projection may not
work properly and give suboptimal results, see <a href="https://github.com/stan-dev/projpred/pull/353" class="external-link">#353</a> on GitHub
(the underlying issue is described in <strong>lme4</strong> issue <a href="https://github.com/lme4/lme4/issues/682" class="external-link">#682</a>). With
suboptimality of the results, we mean that in such cases, the relevance
of the group-level terms can be underestimated. According to the
simulation-based case study from <a href="https://github.com/stan-dev/projpred/pull/353" class="external-link">#353</a>, the
latent projection should be considered as a currently available
remedy.</p>
<p>For multilevel Poisson models, the traditional projection may take
very long, see <a href="https://github.com/stan-dev/projpred/pull/353" class="external-link">#353</a>. According
to the simulation-based case study from <a href="https://github.com/stan-dev/projpred/pull/353" class="external-link">#353</a>, the
latent projection should be considered as a currently available
remedy.</p>
<p>Finally, as illustrated in the Poisson example of the
latent-projection vignette, the latent projection can be beneficial for
non-multilevel models with a (non-Gaussian) family that is also
supported by the traditional projection, at least in case of the Poisson
family and L1 search.</p>
</div>
<div class="section level3">
<h3 id="issues-with-the-augmented-data-projection">Issues with the augmented-data projection<a class="anchor" aria-label="anchor" href="#issues-with-the-augmented-data-projection"></a>
</h3>
<p>For multilevel models, the augmented-data projection seems to suffer
from the same issue as the traditional projection for the binomial
family (see above), i.e., it may not work properly and give suboptimal
results, see <a href="https://github.com/stan-dev/projpred/pull/353" class="external-link">#353</a> (the
underlying issue is probably similar to the one described in
<strong>lme4</strong> issue <a href="https://github.com/lme4/lme4/issues/682" class="external-link">#682</a>). With
suboptimality of the results, we mean that in such cases, the relevance
of the group-level terms can be underestimated. According to the
simulation-based case study from <a href="https://github.com/stan-dev/projpred/pull/353" class="external-link">#353</a>, the
latent projection should be considered as a remedy in such cases.</p>
</div>
<div class="section level3">
<h3 id="speed">Speed<a class="anchor" aria-label="anchor" href="#speed"></a>
</h3>
<p>There are many ways to speed up <strong>projpred</strong>, but in
general, such speed-ups lead to results that are less accurate and hence
should only be considered as <em>preliminary</em> results. Some speed-up
possibilities are:</p>
<ol style="list-style-type: decimal">
<li><p>Using <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = FALSE</code> (which requires
<code>cv_method = "LOO"</code>) instead of
<code>validate_search = TRUE</code>. This approach
(<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with <code>validate_search = FALSE</code>) has
comparable runtime to <code><a href="../reference/varsel.html">varsel()</a></code>, but accounts for some
overfitting, namely that induced by <code><a href="../reference/varsel.html">varsel()</a></code>’s in-sample
predictions during the predictive performance evaluation. However, as
explained in section <a href="#variableselection">“Variable
selection”</a> (see also section <a href="#overfitting">“Overfitting”</a>), <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = FALSE</code> is more prone to overfitting than
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = TRUE</code>.</p></li>
<li><p>Using <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with <span class="math inline">\(K\)</span>-fold CV instead of PSIS-LOO CV (with
<code>validate_search = TRUE</code>). Whether this provides a speed
improvement mainly depends on the number of observations and the
complexity of the reference model. Note that PSIS-LOO CV is often more
accurate than <span class="math inline">\(K\)</span>-fold CV if argument
<code>K</code> is (much) smaller than the number of
observations.</p></li>
<li><p>Using a “custom” reference model object with a dimension
reduction technique for the predictor data (e.g., by computing principal
components from the original predictors, using these principal
components as predictors when fitting the reference model, and then
performing the variable selection in terms of the <em>original</em>
predictor terms). Examples are given in <span class="citation">Piironen,
Paasiniemi, and Vehtari (<a href="#ref-piironen_projective_2020">2020</a>)</span> and <span class="citation">Pavone et al. (<a href="#ref-pavone_using_2022">2022</a>)</span>. This approach makes
sense if there is a large number of predictor variables, in which case
this aims at improving the runtime required for fitting the reference
model and hence improving the runtime of <span class="math inline">\(K\)</span>-fold CV.</p></li>
<li><p>Using <code><a href="../reference/varsel.html">varsel()</a></code> with its argument <code>d_test</code>
for evaluating predictive performance on a hold-out dataset instead of
doing this with <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>’s CV approach. Typically, the
hold-out approach requires a large amount of data.</p></li>
<li><p>Reducing <code>nterms_max</code> in <code><a href="../reference/varsel.html">varsel()</a></code> or
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>. The resulting predictive performance plot(s)
should be inspected to check that the search is not terminated too early
(i.e., before the submodel performance levels off), which would indicate
that <code>nterms_max</code> has been reduced too much.</p></li>
<li><p>Reducing argument <code>nclusters</code> (of
<code><a href="../reference/varsel.html">varsel()</a></code> or <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>) below <code>20</code>
and/or setting <code>nclusters_pred</code> to some non-<code>NULL</code>
(and smaller than <code>400</code>, the default for
<code>ndraws_pred</code>) value. If setting <code>nclusters_pred</code>
as low as <code>nclusters</code> (and using forward search),
<code>refit_prj</code> can instead be set to <code>FALSE</code>, see
below.</p></li>
<li><p>Using L1 search (see argument <code>method</code> of
<code><a href="../reference/varsel.html">varsel()</a></code> or <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>) instead of forward
search. Note that L1 search implies <code>nclusters = 1</code> and is
not always supported. In general, forward search is more accurate than
L1 search and hence more desirable (see section “Details” in
<code><a href="../reference/varsel.html">?varsel</a></code> or <code><a href="../reference/cv_varsel.html">?cv_varsel</a></code> for a more detailed
comparison of the two). The issue demonstrated in the Poisson example
from the latent-projection vignette is related to this.</p></li>
<li><p>Setting argument <code>refit_prj</code> (of <code><a href="../reference/varsel.html">varsel()</a></code>
or <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>) to <code>FALSE</code>, which basically
means to set <code>ndraws_pred = ndraws</code> and
<code>nclusters_pred = nclusters</code>, but in a more efficient (i.e.,
faster) way. In case of L1 search, this means that the L1-penalized
projections of the regression coefficients are used for the predictive
performance evaluation, which may be undesired <span class="citation">(<a href="#ref-piironen_projective_2020">Piironen,
Paasiniemi, and Vehtari 2020, sec. 4</a>)</span>. In case of forward
search, this issue does not exist.</p></li>
<li><p>Parallelizing costly parts of the CV implied by
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> (this was demonstrated in the example above;
see argument <code>parallel</code> of <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>). When
using <code><a href="../reference/project.html">project()</a></code>, parallelizing the projection might also
help (see the general package documentation available <a href="https://mc-stan.org/projpred/reference/projpred-package.html">online</a>
or by typing <code><a href="../reference/projpred-package.html">?`projpred-package`</a></code>).</p></li>
<li><p>Using <code><a href="../reference/run_cvfun.html">run_cvfun()</a></code> in case of repeated <span class="math inline">\(K\)</span>-fold CV with the same <span class="math inline">\(K\)</span> reference model refits. The output of
<code><a href="../reference/run_cvfun.html">run_cvfun()</a></code> is typically used as input for argument
<code>cvfits</code> of <code><a href="../reference/cv_varsel.html">cv_varsel.refmodel()</a></code> (so in order to
have a speed improvement, the output of <code><a href="../reference/run_cvfun.html">run_cvfun()</a></code> needs
to be assigned to an object which is then re-used in multiple
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> calls).</p></li>
</ol>
</div>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-catalina_projection_2022" class="csl-entry">
Catalina, Alejandro, Paul-Christian Bürkner, and Aki Vehtari. 2022.
<span>“Projection Predictive Inference for Generalized Linear and
Additive Multilevel Models.”</span> In <em>Proceedings of
<span>The</span> 25th <span>International Conference</span> on
<span>Artificial Intelligence</span> and <span>Statistics</span></em>,
edited by Gustau Camps-Valls, Francisco J. R. Ruiz, and Isabel Valera,
151:4446–61. Proceedings of <span>Machine Learning Research</span>.
<span>PMLR</span>. <a href="https://proceedings.mlr.press/v151/catalina22a.html" class="external-link">https://proceedings.mlr.press/v151/catalina22a.html</a>.
</div>
<div id="ref-catalina_latent_2021" class="csl-entry">
Catalina, Alejandro, Paul Bürkner, and Aki Vehtari. 2021. <span>“Latent
Space Projection Predictive Inference.”</span> <span>arXiv</span>. <a href="https://doi.org/10.48550/arXiv.2109.04702" class="external-link">https://doi.org/10.48550/arXiv.2109.04702</a>.
</div>
<div id="ref-dupuis_variable_2003" class="csl-entry">
Dupuis, Jérome A., and Christian P. Robert. 2003. <span>“Variable
Selection in Qualitative Models via an Entropic Explanatory
Power.”</span> <em>Journal of Statistical Planning and Inference</em>
111 (1–2): 77–94. <a href="https://doi.org/10.1016/S0378-3758(02)00286-0" class="external-link">https://doi.org/10.1016/S0378-3758(02)00286-0</a>.
</div>
<div id="ref-goutis_model_1998" class="csl-entry">
Goutis, Constantinos, and Christian P. Robert. 1998. <span>“Model Choice
in Generalised Linear Models: <span>A Bayesian</span> Approach via
<span>Kullback-Leibler</span> Projections.”</span> <em>Biometrika</em>
85 (1): 29–37.
</div>
<div id="ref-pavone_using_2022" class="csl-entry">
Pavone, Federico, Juho Piironen, Paul-Christian Bürkner, and Aki
Vehtari. 2022. <span>“Using Reference Models in Variable
Selection.”</span> <em>Computational Statistics</em>. <a href="https://doi.org/10.1007/s00180-022-01231-6" class="external-link">https://doi.org/10.1007/s00180-022-01231-6</a>.
</div>
<div id="ref-piironen_projective_2020" class="csl-entry">
Piironen, Juho, Markus Paasiniemi, and Aki Vehtari. 2020.
<span>“Projective Inference in High-Dimensional Problems:
<span>Prediction</span> and Feature Selection.”</span> <em>Electronic
Journal of Statistics</em> 14 (1): 2155–97. <a href="https://doi.org/10.1214/20-EJS1711" class="external-link">https://doi.org/10.1214/20-EJS1711</a>.
</div>
<div id="ref-piironen_comparison_2017" class="csl-entry">
Piironen, Juho, and Aki Vehtari. 2017a. <span>“Comparison of
<span>Bayesian</span> Predictive Methods for Model Selection.”</span>
<em>Statistics and Computing</em> 27 (3): 711–35. <a href="https://doi.org/10.1007/s11222-016-9649-y" class="external-link">https://doi.org/10.1007/s11222-016-9649-y</a>.
</div>
<div id="ref-piironen_hyperprior_2017" class="csl-entry">
———. 2017b. <span>“On the Hyperprior Choice for the Global Shrinkage
Parameter in the Horseshoe Prior.”</span> In <em>Proceedings of the 20th
<span>International Conference</span> on <span>Artificial
Intelligence</span> and <span>Statistics</span></em>, edited by Aarti
Singh and Jerry Zhu, 54:905–13. Proceedings of <span>Machine Learning
Research</span>. <span>PMLR</span>. <a href="https://proceedings.mlr.press/v54/piironen17a.html" class="external-link">https://proceedings.mlr.press/v54/piironen17a.html</a>.
</div>
<div id="ref-piironen_sparsity_2017" class="csl-entry">
———. 2017c. <span>“Sparsity Information and Regularization in the
Horseshoe and Other Shrinkage Priors.”</span> <em>Electronic Journal of
Statistics</em> 11 (2): 5018–51. <a href="https://doi.org/10.1214/17-EJS1337SI" class="external-link">https://doi.org/10.1214/17-EJS1337SI</a>.
</div>
<div id="ref-vehtari_practical_2017" class="csl-entry">
Vehtari, Aki, Andrew Gelman, and Jonah Gabry. 2017. <span>“Practical
<span>Bayesian</span> Model Evaluation Using Leave-One-Out
Cross-Validation and <span>WAIC</span>.”</span> <em>Statistics and
Computing</em> 27 (5): 1413–32. <a href="https://doi.org/10.1007/s11222-016-9696-4" class="external-link">https://doi.org/10.1007/s11222-016-9696-4</a>.
</div>
<div id="ref-vehtari_pareto_2022" class="csl-entry">
Vehtari, Aki, Daniel Simpson, Andrew Gelman, Yuling Yao, and Jonah
Gabry. 2022. <span>“Pareto Smoothed Importance Sampling.”</span>
<span>arXiv</span>. <a href="https://doi.org/10.48550/arXiv.1507.02646" class="external-link">https://doi.org/10.48550/arXiv.1507.02646</a>.
</div>
<div id="ref-weber_projection_2023" class="csl-entry">
Weber, Frank, Änne Glass, and Aki Vehtari. 2023. <span>“Projection
Predictive Variable Selection for Discrete Response Families with Finite
Support.”</span> <span>arXiv</span>. <a href="https://doi.org/10.48550/arXiv.2301.01660" class="external-link">https://doi.org/10.48550/arXiv.2301.01660</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>The citation information can be accessed offline by
typing <code>print(citation("projpred"), bibtex = TRUE)</code> within
R.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>We will cover custom reference models more deeply in a
future vignette.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>More generally, the number of chains is split up as
evenly as possible among the number of CPU cores.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>Currently, neither <code><a href="../reference/varsel.html">varsel()</a></code> nor
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> (not even <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = TRUE</code>) guard against overfitting in the
selection of the submodel <em>size</em>. This is why we added
“approximately” to “valid post-selection inference” in section <a href="#intro">“Introduction”</a>. Typically, however, the overfitting
induced by the size selection should be comparatively small <span class="citation">(<a href="#ref-piironen_comparison_2017">Piironen and
Vehtari 2017a</a>)</span>.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p>In general, only <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with
<code>validate_search = TRUE</code> (which we have here) allows to judge
whether the submodels perform better than the reference model or not.
Such a judgment is not possible with <code><a href="../reference/varsel.html">varsel()</a></code> or
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> with <code>validate_search = FALSE</code> (in
general).<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p><code><a href="../reference/print.vsel.html">print.vsel()</a></code> is the method that is called
when simply printing an object resulting from <code><a href="../reference/varsel.html">varsel()</a></code> or
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>During the search, the reference model is projected onto
all candidate models (this is where arguments <code>ndraws</code> and
<code>nclusters</code> of <code><a href="../reference/varsel.html">varsel()</a></code> and
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> come into play; note that in case of an L1
search, the projection is L1-penalized). For the evaluation of the
submodels along the predictor ranking returned by the search, the
reference model is projected onto these submodels again (this is where
arguments <code>ndraws_pred</code> and <code>nclusters_pred</code> of
<code><a href="../reference/varsel.html">varsel()</a></code> and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> come into play; note
that this only holds if argument <code>refit_prj</code> of
<code><a href="../reference/varsel.html">varsel()</a></code> and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> is set to
<code>TRUE</code>, as by default). Within <code><a href="../reference/project.html">project()</a></code>,
<code>refit_prj = FALSE</code> allows to re-use the submodel fits (that
is, the projections) from the full-data search of a <code>vsel</code>
object, but usually, the search relies on a rather coarse clustering or
thinning of the reference model’s posterior draws (by default,
<code><a href="../reference/varsel.html">varsel()</a></code> and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> use
<code>nclusters = 20</code>—or <code>nclusters = 1</code> in case of L1
search), which would then imply the same coarseness for a
<code><a href="../reference/project.html">project()</a></code> call where <code>refit_prj</code> is set to
<code>FALSE</code>. In general, we want the final projection (that
post-selection inference is based on) to be as accurate as possible, so
here we call <code><a href="../reference/project.html">project()</a></code> with the defaults of
<code>refit_prj = TRUE</code> and <code>ndraws = 400</code>. For more
accurate results, we could increase argument <code>ndraws</code> of
<code><a href="../reference/project.html">project()</a></code> (up to the number of posterior draws in the
reference model). However, this would increase the runtime, which we
don’t want in this vignette.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>In general, this implies that projected regression
coefficients do not reflect isolated effects of the predictors. For
example, especially in case of highly correlated predictors, it is
possible that projected regression coefficients “absorb” effects from
predictors that have been excluded in the projection.<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p><code><a href="../reference/pred-projection.html">proj_predict()</a></code> also has an argument
<code>return_draws_matrix</code>, but it simply converts the return
value type. In <code><a href="../reference/pred-projection.html">proj_predict()</a></code>, different weights of the
projected draws are taken into account via argument
<code>nresample_clusters</code>.<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p><code><a href="../reference/pred-projection.html">proj_linpred()</a></code> can also transform the
linear predictor to response scale, but here, this is the same as the
linear predictor scale (because of the identity link function).<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
<li id="fn11"><p>In case of the Gaussian family we are using here, the
uncertainty arising from the observation model is the uncertainty due to
the residual standard deviation.<a href="#fnref11" class="footnote-back">↩︎</a></p></li>
<li id="fn12"><p>Via <code><a href="https://paul-buerkner.github.io/brms/reference/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code>, the
<code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::bernoulli()</a></code> family is supported as well.<a href="#fnref12" class="footnote-back">↩︎</a></p></li>
<li id="fn13"><p>Currently, the augmented-data support for the
<code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code> family does not include binomial distributions
with more than one trial. In such a case, a workaround is to
de-aggregate the Bernoulli trials which belong to the same (aggregated)
observation, i.e., to use a “long” dataset.<a href="#fnref13" class="footnote-back">↩︎</a></p></li>
<li id="fn14"><p>Like the traditional projection, the augmented-data
projection also supports the <code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::bernoulli()</a></code> family via
<code><a href="https://paul-buerkner.github.io/brms/reference/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code>.<a href="#fnref14" class="footnote-back">↩︎</a></p></li>
<li id="fn15"><p>For the augmented-data projection based on a “typical”
<strong>brms</strong> reference model object, <strong>brms</strong>
version 2.17.0 or later is needed.<a href="#fnref15" class="footnote-back">↩︎</a></p></li>
<li id="fn16"><p>More <strong>brms</strong> families might be supported
in the future.<a href="#fnref16" class="footnote-back">↩︎</a></p></li>
<li id="fn17"><p>Currently, the latent-projection support for the
<code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code> family does not include binomial distributions
with more than one trial. In such a case, a workaround is to
de-aggregate the Bernoulli trials which belong to the same (aggregated)
observation, i.e., to use a “long” dataset.<a href="#fnref17" class="footnote-back">↩︎</a></p></li>
<li id="fn18"><p>Like the traditional projection, the latent projection
also supports the <code><a href="https://paul-buerkner.github.io/brms/reference/brmsfamily.html" class="external-link">brms::bernoulli()</a></code> family via
<code><a href="https://paul-buerkner.github.io/brms/reference/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code>.<a href="#fnref18" class="footnote-back">↩︎</a></p></li>
<li id="fn19"><p>For the latent projection based on a “typical”
<strong>brms</strong> reference model object, <strong>brms</strong>
version 2.19.0 or later is needed.<a href="#fnref19" class="footnote-back">↩︎</a></p></li>
<li id="fn20"><p>Multilevel models are also known as
<em>hierarchical</em> models or models with <em>partially pooled</em>,
<em>group-level</em>, or—in frequentist terms—<em>random</em> effects.<a href="#fnref20" class="footnote-back">↩︎</a></p></li>
<li id="fn21"><p>Additive terms are also known as <em>smooth</em>
terms.<a href="#fnref21" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Juho Piironen, Markus Paasiniemi, Alejandro Catalina, Frank Weber, Aki Vehtari.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
