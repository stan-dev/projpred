<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>projpred: Projection predictive feature selection • projpred</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cosmo/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="projpred: Projection predictive feature selection">
<meta property="og:description" content="projpred">
<meta property="og:image" content="https://mc-stan.org/projpred/logo.svg">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">projpred</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">2.3.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fa fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/index.html">Vignettes</a>
</li>
<li>
  <a href="../reference/index.html">Functions</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Other Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="https://mc-stan.org/rstan" class="external-link">rstan</a>
    </li>
    <li>
      <a href="https://mc-stan.org/cmdstanr" class="external-link">cmdstanr</a>
    </li>
    <li>
      <a href="https://mc-stan.org/rstanarm" class="external-link">rstanarm</a>
    </li>
    <li>
      <a href="https://mc-stan.org/bayesplot" class="external-link">bayesplot</a>
    </li>
    <li>
      <a href="https://mc-stan.org/shinystan" class="external-link">shinystan</a>
    </li>
    <li>
      <a href="https://mc-stan.org/loo" class="external-link">loo</a>
    </li>
    <li>
      <a href="https://mc-stan.org/rstantools" class="external-link">rstantools</a>
    </li>
    <li>
      <a href="https://mc-stan.org/posterior" class="external-link">posterior</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://mc-stan.org" class="external-link">Stan</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://twitter.com/mcmc_stan" class="external-link">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
<li>
  <a href="https://github.com/stan-dev/projpred/" class="external-link">
    <span class="fa fa-github"></span>
     
  </a>
</li>
<li>
  <a href="https://discourse.mc-stan.org/" class="external-link">
    <span class="fa fa-users"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>projpred: Projection predictive feature
selection</h1>
            
            <h4 data-toc-skip class="date">2023-01-15</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/stan-dev/projpred/blob/HEAD/vignettes/projpred.Rmd" class="external-link"><code>vignettes/projpred.Rmd</code></a></small>
      <div class="hidden name"><code>projpred.Rmd</code></div>

    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This vignette shows the main functionalities of the
<strong>projpred</strong> package, which implements the projection
predictive variable selection for various regression models (see section
<a href="#modtypes">“Supported types of models”</a> below for more
details on supported model types). What is special about the projection
predictive variable selection is that it not only performs a variable
selection, but also allows for valid post-selection inference.</p>
<p>The projection predictive variable selection is based on the ideas of
<span class="citation">Goutis and Robert (<a href="#ref-goutis_model_1998" role="doc-biblioref">1998</a>)</span> and
<span class="citation">Dupuis and Robert (<a href="#ref-dupuis_variable_2003" role="doc-biblioref">2003</a>)</span>.
The methods implemented in <strong>projpred</strong> are described in
detail in <span class="citation">Piironen, Paasiniemi, and Vehtari (<a href="#ref-piironen_projective_2020" role="doc-biblioref">2020</a>)</span> and <span class="citation">Catalina, Bürkner, and Vehtari (<a href="#ref-catalina_projection_2022" role="doc-biblioref">2022</a>)</span>. They are evaluated in comparison
to many other methods in <span class="citation">Piironen and Vehtari (<a href="#ref-piironen_comparison_2017" role="doc-biblioref">2017a</a>)</span>. For details on how to cite
<strong>projpred</strong>, see the <a href="https://CRAN.R-project.org/package=projpred/citation.html" class="external-link">projpred
citation info</a> on CRAN.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
</div>
<div class="section level2">
<h2 id="data">Data<a class="anchor" aria-label="anchor" href="#data"></a>
</h2>
<p>For this vignette, we use <strong>projpred</strong>’s
<code>df_gaussian</code> data. It contains 100 observations of 20
continuous predictor variables <code>X1</code>, …, <code>X20</code>
(originally stored in a sub-matrix; we turn them into separate columns
below) and one continuous response variable <code>y</code>.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"df_gaussian"</span>, package <span class="op">=</span> <span class="st">"projpred"</span><span class="op">)</span></span>
<span><span class="va">dat_gauss</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">df_gaussian</span><span class="op">$</span><span class="va">y</span>, <span class="va">df_gaussian</span><span class="op">$</span><span class="va">x</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="refmod">Reference model<a class="anchor" aria-label="anchor" href="#refmod"></a>
</h2>
<p>First, we have to construct a reference model for the projection
predictive variable selection. This model is considered as the best
(“reference”) solution to the prediction task. The aim of the projection
predictive variable selection is to find a subset of a set of candidate
predictors which is as small as possible but achieves a predictive
performance as close as possible to that of the reference model.</p>
<p>Usually (and this is also the case in this vignette), the reference
model will be an <a href="https://mc-stan.org/rstanarm/" class="external-link"><strong>rstanarm</strong></a> or <a href="https://paul-buerkner.github.io/brms/" class="external-link"><strong>brms</strong></a>
fit. To our knowledge, <strong>rstanarm</strong> and
<strong>brms</strong> are currently the only packages for which a
<code><a href="../reference/refmodel-init-get.html">get_refmodel()</a></code> method (which establishes the compatibility
with <strong>projpred</strong>) exists. Creating a reference model
object via one of these <code><a href="../reference/refmodel-init-get.html">get_refmodel.stanreg()</a></code> or
<code><a href="https://rdrr.io/pkg/brms/man/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code> methods (either implicitly by
a call to a top-level function such as <code><a href="../reference/project.html">project()</a></code>,
<code><a href="../reference/varsel.html">varsel()</a></code>, and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>, as done below, or
explicitly by a call to <code><a href="../reference/refmodel-init-get.html">get_refmodel()</a></code>) leads to a
“typical” reference model object. In that case, all candidate models are
actual <em>sub</em>models of the reference model. In general, however,
this assumption is not necessary for a projection predictive variable
selection <span class="citation">(see, e.g., <a href="#ref-piironen_projective_2020" role="doc-biblioref">Piironen,
Paasiniemi, and Vehtari 2020</a>)</span>. This is why “custom” (i.e.,
non-“typical”) reference model objects allow to avoid this assumption
(although the candidate models of a “custom” reference model object will
still be actual <em>sub</em>models of the full <code>formula</code> used
by the search procedure—which does not have to be the same as the
reference model’s <code>formula</code>, if the reference model possesses
a <code>formula</code> at all). Such “custom” reference model objects
can be constructed via <code><a href="../reference/refmodel-init-get.html">init_refmodel()</a></code> (or
<code><a href="../reference/refmodel-init-get.html">get_refmodel.default()</a></code>), as shown in section “Examples” of
the <code><a href="../reference/refmodel-init-get.html">?init_refmodel</a></code> help.<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a></p>
<p>Here, we use the <strong>rstanarm</strong> package to fit the
reference model. If you want to use the <strong>brms</strong> package,
simply replace the <strong>rstanarm</strong> fit (of class
<code>stanreg</code>) in all the code below by your
<strong>brms</strong> fit (of class <code>brmsfit</code>). Only note
that in case of a <strong>brms</strong> fit, we recommend to specify
argument <code>brms_seed</code> of
<code><a href="https://rdrr.io/pkg/brms/man/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/rstanarm/" class="external-link">rstanarm</a></span><span class="op">)</span></span></code></pre></div>
<p>For our <strong>rstanarm</strong> reference model, we use the
Gaussian distribution as the <code>family</code> for our response. With
respect to the predictors, we only include the linear main effects of
all 20 predictor variables. Compared to the more complex types of
reference models supported by <strong>projpred</strong> (see section <a href="#modtypes">“Supported types of models”</a> below), this is a quite
simple reference model which is sufficient, however, to demonstrate the
interplay of <strong>projpred</strong>’s functions.</p>
<p>We use <strong>rstanarm</strong>’s default priors in our reference
model, except for the regression coefficients for which we use a
regularized horseshoe prior <span class="citation">(<a href="#ref-piironen_sparsity_2017" role="doc-biblioref">Piironen and
Vehtari 2017c</a>)</span> with the hyperprior for its global shrinkage
parameter following <span class="citation">Piironen and Vehtari (<a href="#ref-piironen_hyperprior_2017" role="doc-biblioref">2017b</a>)</span> and <span class="citation">Piironen and Vehtari (<a href="#ref-piironen_sparsity_2017" role="doc-biblioref">2017c</a>)</span>. In R code, these are the
preparation steps for the regularized horseshoe prior:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Number of regression coefficients:</span></span>
<span><span class="op">(</span> <span class="va">D</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/grep.html" class="external-link">grepl</a></span><span class="op">(</span><span class="st">"^X"</span>, <span class="fu"><a href="https://rdrr.io/r/base/names.html" class="external-link">names</a></span><span class="op">(</span><span class="va">dat_gauss</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>[1] 20</code></pre>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Prior guess for the number of relevant (i.e., non-zero) regression</span></span>
<span><span class="co"># coefficients:</span></span>
<span><span class="va">p0</span> <span class="op">&lt;-</span> <span class="fl">5</span></span>
<span><span class="co"># Number of observations:</span></span>
<span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">dat_gauss</span><span class="op">)</span></span>
<span><span class="co"># Hyperprior scale for tau, the global shrinkage parameter (note that for the</span></span>
<span><span class="co"># Gaussian family, 'rstanarm' will automatically scale this by the residual</span></span>
<span><span class="co"># standard deviation):</span></span>
<span><span class="va">tau0</span> <span class="op">&lt;-</span> <span class="va">p0</span> <span class="op">/</span> <span class="op">(</span><span class="va">D</span> <span class="op">-</span> <span class="va">p0</span><span class="op">)</span> <span class="op">*</span> <span class="fl">1</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="va">N</span><span class="op">)</span></span></code></pre></div>
<p>We now fit the reference model to the data. To make this vignette
build faster, we use only 2 MCMC chains and 500 iterations per chain
(with half of them being discarded as warmup draws). In practice, 4
chains and 2000 iterations per chain are reasonable defaults.
Furthermore, we make use of <strong>rstan</strong>’s parallelization,
which means to run each chain on a separate CPU core.<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> If you run the
following code yourself, you can either rely on an automatic mechanism
to detect the number of CPU cores (like the
<code><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">parallel::detectCores()</a></code> function shown below) or adapt
<code>ncores</code> manually to your system.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Set this manually if desired:</span></span>
<span><span class="va">ncores</span> <span class="op">&lt;-</span> <span class="fu">parallel</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/r/parallel/detectCores.html" class="external-link">detectCores</a></span><span class="op">(</span>logical <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="co">### Only for technical reasons in this vignette (you can omit this when running</span></span>
<span><span class="co">### the code yourself):</span></span>
<span><span class="va">ncores</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">ncores</span>, <span class="fl">2L</span><span class="op">)</span></span>
<span><span class="co">###</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/options.html" class="external-link">options</a></span><span class="op">(</span>mc.cores <span class="op">=</span> <span class="va">ncores</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_glm.html" class="external-link">stan_glm</a></span><span class="op">(</span></span>
<span>  <span class="va">y</span> <span class="op">~</span> <span class="va">X1</span> <span class="op">+</span> <span class="va">X2</span> <span class="op">+</span> <span class="va">X3</span> <span class="op">+</span> <span class="va">X4</span> <span class="op">+</span> <span class="va">X5</span> <span class="op">+</span> <span class="va">X6</span> <span class="op">+</span> <span class="va">X7</span> <span class="op">+</span> <span class="va">X8</span> <span class="op">+</span> <span class="va">X9</span> <span class="op">+</span> <span class="va">X10</span> <span class="op">+</span> <span class="va">X11</span> <span class="op">+</span> <span class="va">X12</span> <span class="op">+</span> <span class="va">X13</span> <span class="op">+</span> <span class="va">X14</span> <span class="op">+</span></span>
<span>    <span class="va">X15</span> <span class="op">+</span> <span class="va">X16</span> <span class="op">+</span> <span class="va">X17</span> <span class="op">+</span> <span class="va">X18</span> <span class="op">+</span> <span class="va">X19</span> <span class="op">+</span> <span class="va">X20</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">dat_gauss</span>,</span>
<span>  prior <span class="op">=</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/priors.html" class="external-link">hs</a></span><span class="op">(</span>global_scale <span class="op">=</span> <span class="va">tau0</span><span class="op">)</span>,</span>
<span>  <span class="co">### Only for the sake of speed (not recommended in general):</span></span>
<span>  chains <span class="op">=</span> <span class="fl">2</span>, iter <span class="op">=</span> <span class="fl">500</span>,</span>
<span>  <span class="co">###</span></span>
<span>  seed <span class="op">=</span> <span class="fl">2052109</span>, QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Usually, we would now have to check the convergence diagnostics (see,
e.g., <code><a href="https://mc-stan.org/posterior/reference/diagnostics.html" class="external-link">?posterior::diagnostics</a></code> and
<code><a href="https://mc-stan.org/posterior/reference/draws_summary.html" class="external-link">?posterior::default_convergence_measures</a></code>). However, due to
the technical reasons for which we reduced <code>chains</code> and
<code>iter</code>, we skip this step here.</p>
</div>
<div class="section level2">
<h2 id="variable-selection">Variable selection<a class="anchor" aria-label="anchor" href="#variable-selection"></a>
</h2>
<p>Now, <strong>projpred</strong> comes into play.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/projpred/">projpred</a></span><span class="op">)</span></span></code></pre></div>
<p>In <strong>projpred</strong>, the projection predictive variable
selection consists of a <em>search</em> part and an <em>evaluation</em>
part. The search part determines the solution path, i.e., the best
submodel for each submodel size (number of predictor terms). The
evaluation part determines the predictive performance of the submodels
along the solution path.</p>
<p>There are two functions for performing the variable selection:
<code><a href="../reference/varsel.html">varsel()</a></code> and <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code>. In contrast to
<code><a href="../reference/varsel.html">varsel()</a></code>, <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> performs a
cross-validation (CV) by running the search part with the training data
of each CV fold separately (an exception is
<code>validate_search = FALSE</code>, see <code><a href="../reference/cv_varsel.html">?cv_varsel</a></code> and
below) and running the evaluation part on the corresponding test set of
each CV fold. Because of this CV, <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> is
recommended over <code><a href="../reference/varsel.html">varsel()</a></code>. Thus, we use
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> here. Nonetheless, running
<code><a href="../reference/varsel.html">varsel()</a></code> first can offer a rough idea of the performance of
the submodels (after projecting the reference model onto them). A more
principled <strong>projpred</strong> workflow is work under
progress.</p>
<!-- In versions > 2.0.2, **projpred** offers a parallelization of the projection. Typically, this only makes sense for a large number of projected draws. Therefore, this parallelization is not activated by a simple logical switch, but by a threshold for the number of projected draws below which no parallelization will be used. Values greater than or equal to this threshold will trigger the parallelization. For more information, see the general package documentation available at ``?`projpred-package` ``. There, we also explain why we are not running the parallelization on Windows and why we cannot recommend the parallelization of the projection for some types of reference models (see also section ["Supported types of models"](#modtypes) below). -->
<!-- ```{r} -->
<!-- if (!identical(.Platform$OS.type, "windows")) { -->
<!--   trigger_default <- options(projpred.prll_prj_trigger = 200) -->
<!--   library(doParallel) -->
<!--   registerDoParallel(ncores) -->
<!-- } -->
<!-- ``` -->
<p>Here, we use only some of the available arguments; see the
documentation of <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> for the full list of
arguments. By default, <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> runs a leave-one-out
(LOO) CV (see argument <code>cv_method</code>) which also
cross-validates the search (see argument <code>validate_search</code>).
Here, we set argument <code>validate_search</code> to <code>FALSE</code>
to obtain rough preliminary results and make this vignette build faster.
If possible (in terms of computation time), we recommend using the
default of <code>validate_search = TRUE</code> to avoid overfitting in
the selection of the submodel size. Here, we also set
<code>nclusters_pred</code> to a low value of <code>20</code> only to
speed up the building of the vignette. By modifying argument
<code>nterms_max</code>, we impose a limit on the submodel size until
which the search is continued. Typically, one has to run the variable
selection with a large <code>nterms_max</code> first (the default value
may not even be large enough) and only after inspecting the results from
this first run, one is able to set a reasonable <code>nterms_max</code>
in subsequent runs. The value we are using here (<code>9</code>) is
based on such a first run (which is not shown here, though).</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cvvs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/cv_varsel.html">cv_varsel</a></span><span class="op">(</span></span>
<span>  <span class="va">refm_fit</span>,</span>
<span>  <span class="co">### Only for the sake of speed (not recommended in general):</span></span>
<span>  validate_search <span class="op">=</span> <span class="cn">FALSE</span>,</span>
<span>  nclusters_pred <span class="op">=</span> <span class="fl">20</span>,</span>
<span>  <span class="co">###</span></span>
<span>  nterms_max <span class="op">=</span> <span class="fl">9</span>,</span>
<span>  seed <span class="op">=</span> <span class="fl">411183</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The first step after running the variable selection should be the
decision for a final submodel size. This should be the first step (in
particular, before inspecting the solution path) in order to avoid a
user-induced selection bias (which could occur if the user made the
submodel size decision dependent on the solution path). To decide for a
submodel size, there are several performance statistics we can plot as a
function of the submodel size. Here, we use the expected log (pointwise)
predictive density (for a new dataset) (ELPD; empirically, this is the
sum of the log predictive densities of the observations in the
evaluation—or “test”—set) and the root mean squared error (RMSE). By
default, the performance statistics are plotted on their original scale,
but with <code>deltas = TRUE</code>, they are calculated as differences
from a baseline model (which is the reference model by default, at least
in the most common cases). Since the differences are usually of more
interest (with regard to the submodel size decision), we directly plot
with <code>deltas = TRUE</code> here (note that as
<code>validate_search = FALSE</code>, this result is slightly
optimistic, and the plot looks different when
<code>validate_search = TRUE</code> is used):</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">cvvs</span>, stats <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"elpd"</span>, <span class="st">"rmse"</span><span class="op">)</span>, deltas <span class="op">=</span> <span class="cn">TRUE</span>, seed <span class="op">=</span> <span class="fl">54548</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/unnamed-chunk-9-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>Based on that plot (see <code><a href="../reference/plot.vsel.html">?plot.vsel</a></code> for a description),
we would decide for a submodel size of 6 because that’s the point where
the performance measures level off and are close enough to the reference
model’s performance (note that since the plot is affected by
<code>validate_search = FALSE</code>, this manual decision based on the
plot is affected, too):</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">modsize_decided</span> <span class="op">&lt;-</span> <span class="fl">6</span></span></code></pre></div>
<p>Note that <strong>projpred</strong> offers the
<code><a href="../reference/suggest_size.html">suggest_size()</a></code> function which may help in the decision for
a submodel size, but this is a rather heuristic method and needs to be
interpreted with caution (see <code><a href="../reference/suggest_size.html">?suggest_size</a></code>):</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/suggest_size.html">suggest_size</a></span><span class="op">(</span><span class="va">cvvs</span><span class="op">)</span></span></code></pre></div>
<pre><code>[1] 6</code></pre>
<p>Here, we would get the same final submodel size (<code>6</code>) as
by our manual decision (<code><a href="../reference/suggest_size.html">suggest_size()</a></code> is also affected by
<code>validate_search = FALSE</code>). Note that by default,
<code><a href="../reference/suggest_size.html">suggest_size()</a></code> uses the ELPD as performance statistic.</p>
<p>Only now, after we have made a decision for the submodel size, we
inspect further results from the variable selection and, in particular,
the solution path. For example, we can simply <code><a href="https://rdrr.io/r/base/print.html" class="external-link">print()</a></code> the
resulting object:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">cvvs</span></span></code></pre></div>
<pre><code>
Family: gaussian 
Link function: identity 

Formula: y ~ X1 + X2 + X3 + X4 + X5 + X6 + X7 + X8 + X9 + X10 + X11 + 
    X12 + X13 + X14 + X15 + X16 + X17 + X18 + X19 + X20
Observations: 100
CV method: LOO search not included 
Search method: l1, maximum number of terms 9
Number of clusters used for selection: 1
Number of clusters used for prediction: 20
Suggested Projection Size: 6

Selection Summary:
 size solution_terms elpd.loo  se   diff diff.se
    0           &lt;NA&gt;   -249.2 5.6 -102.1     7.7
    1             X1   -230.6 6.1  -83.5     8.2
    2            X14   -205.0 6.2  -58.0     7.5
    3             X5   -196.5 7.2  -49.4     7.6
    4            X20   -177.7 5.9  -30.6     6.3
    5             X6   -168.8 5.0  -21.7     6.0
    6             X3   -146.6 5.1    0.5     4.6
    7             X8   -138.2 4.5    8.9     3.3
    8            X11   -135.4 4.5   11.7     2.3
    9            X10   -135.0 4.4   12.1     2.2</code></pre>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">### Alternative modifying the number of printed decimal places:</span></span>
<span><span class="co"># print(cvvs, digits = 2)</span></span>
<span><span class="co">### </span></span></code></pre></div>
<p>The solution path can be seen in the <code><a href="https://rdrr.io/r/base/print.html" class="external-link">print()</a></code> output
(column <code>solution_terms</code>), but it is also accessible through
the <code><a href="../reference/solution_terms.html">solution_terms()</a></code> function:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">soltrms</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/solution_terms.html">solution_terms</a></span><span class="op">(</span><span class="va">cvvs</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>[1] "X1"  "X14" "X5"  "X20" "X6"  "X3"  "X8"  "X11" "X10"</code></pre>
<p>Combining the decided submodel size of 6 with the solution path leads
to the following terms (as well as the intercept) as the predictor terms
of the final submodel:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">soltrms_final</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">soltrms</span>, <span class="va">modsize_decided</span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>[1] "X1"  "X14" "X5"  "X20" "X6"  "X3" </code></pre>
</div>
<div class="section level2">
<h2 id="post-selection-inference">Post-selection inference<a class="anchor" aria-label="anchor" href="#post-selection-inference"></a>
</h2>
<p>The <code><a href="../reference/project.html">project()</a></code> function returns an object of class
<code>projection</code> which forms the basis for convenient
post-selection inference. By the following code, <code><a href="../reference/project.html">project()</a></code>
will project the reference model onto the final submodel once again<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/project.html">project</a></span><span class="op">(</span><span class="va">refm_fit</span>, solution_terms <span class="op">=</span> <span class="va">soltrms_final</span><span class="op">)</span></span></code></pre></div>
<!-- Alternative, as soon as GitHub issue #168 is resolved: -->
<!-- ```{r} -->
<!-- prj <- project( -->
<!--   cvvs, -->
<!--   nterms = modsize_decided, -->
<!--   refit_prj = FALSE -->
<!-- ) -->
<!-- ``` -->
<p>For more accurate results, we could have increased argument
<code>ndraws</code> of <code><a href="../reference/project.html">project()</a></code> (up to the number of
posterior draws in the reference model). This increases the runtime,
which we don’t want in this vignette.</p>
<p>Next, we create a matrix containing the projected posterior draws
stored in the depths of <code><a href="../reference/project.html">project()</a></code>’s output:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">prj</span><span class="op">)</span></span></code></pre></div>
<p>This matrix is all we need for post-selection inference. It can be
used like any matrix of draws from MCMC procedures, except that it
doesn’t reflect a typical posterior distribution, but rather a projected
posterior distribution, i.e., the distribution arising from the
deterministic projection of the reference model’s posterior distribution
onto the parameter space of the final submodel.</p>
<div class="section level3">
<h3 id="marginals-of-the-projected-posterior">Marginals of the projected posterior<a class="anchor" aria-label="anchor" href="#marginals-of-the-projected-posterior"></a>
</h3>
<p>The <strong>posterior</strong> package provides a general way to deal
with posterior distributions, so it can also be applied to our projected
posterior. For example, to calculate summary statistics for the
marginals of the projected posterior:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/posterior/" class="external-link">posterior</a></span><span class="op">)</span></span>
<span><span class="va">prj_drws</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/posterior/reference/draws_matrix.html" class="external-link">as_draws_matrix</a></span><span class="op">(</span><span class="va">prj_mat</span><span class="op">)</span></span>
<span><span class="co"># In the following call, as.data.frame() is used only because pkgdown</span></span>
<span><span class="co"># versions &gt; 1.6.1 don't print the tibble correctly.</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://mc-stan.org/posterior/reference/draws_summary.html" class="external-link">summarize_draws</a></span><span class="op">(</span></span>
<span>  <span class="va">prj_drws</span>,</span>
<span>  <span class="st">"median"</span>, <span class="st">"mad"</span>, <span class="kw">function</span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="fu"><a href="https://rdrr.io/r/stats/quantile.html" class="external-link">quantile</a></span><span class="op">(</span><span class="va">x</span>, probs <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.025</span>, <span class="fl">0.975</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>     variable     median        mad       2.5%      97.5%
1 (Intercept)  0.0458985 0.10183583 -0.1505310  0.2205816
2          X1  1.3834312 0.09130185  1.1956560  1.5532896
3         X14 -1.1157218 0.09405313 -1.2834051 -0.9318850
4          X5 -0.9136915 0.11058452 -1.1096153 -0.7263205
5         X20 -1.1185014 0.10942521 -1.3460276 -0.9092710
6          X6  0.5395952 0.09545216  0.3489350  0.7149177
7          X3  0.7767160 0.09659702  0.5948437  0.9772419
8       sigma  1.1304147 0.08527177  0.9919125  1.3107667</code></pre>
<p>A visualization of the projected posterior can be achieved with the
<strong>bayesplot</strong> package, for example using its
<code><a href="https://mc-stan.org/bayesplot/reference/MCMC-intervals.html" class="external-link">mcmc_intervals()</a></code> function:</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://mc-stan.org/bayesplot/" class="external-link">bayesplot</a></span><span class="op">)</span></span>
<span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/bayesplot_theme_get.html" class="external-link">bayesplot_theme_set</a></span><span class="op">(</span><span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggtheme.html" class="external-link">theme_bw</a></span><span class="op">(</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/MCMC-intervals.html" class="external-link">mcmc_intervals</a></span><span class="op">(</span><span class="va">prj_mat</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/coord_cartesian.html" class="external-link">coord_cartesian</a></span><span class="op">(</span>xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.6</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/unnamed-chunk-18-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>Note that we only visualize the <em>1-dimensional</em> marginals of
the projected posterior here. To gain a more complete picture, we would
have to visualize at least some <em>2-dimensional</em> marginals of the
projected posterior (i.e., marginals for pairs of parameters).</p>
<p>For comparison, consider the marginal posteriors of the corresponding
parameters in the reference model:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">refm_mat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">refm_fit</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/MCMC-intervals.html" class="external-link">mcmc_intervals</a></span><span class="op">(</span><span class="va">refm_mat</span>, pars <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">colnames</a></span><span class="op">(</span><span class="va">prj_mat</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span></span>
<span>  <span class="fu">ggplot2</span><span class="fu">::</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/coord_cartesian.html" class="external-link">coord_cartesian</a></span><span class="op">(</span>xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1.5</span>, <span class="fl">1.6</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/unnamed-chunk-19-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>Here, the reference model’s marginal posteriors differ only slightly
from the marginals of the projected posterior. This does not necessarily
have to be the case.</p>
</div>
<div class="section level3">
<h3 id="predictions">Predictions<a class="anchor" aria-label="anchor" href="#predictions"></a>
</h3>
<p>Predictions from the final submodel can be made by
<code><a href="../reference/pred-projection.html">proj_linpred()</a></code> and <code><a href="../reference/pred-projection.html">proj_predict()</a></code>.</p>
<p>We start with <code><a href="../reference/pred-projection.html">proj_linpred()</a></code>. For example, suppose we
have the following new observations:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="op">(</span> <span class="va">dat_gauss_new</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/setNames.html" class="external-link">setNames</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/as.data.frame.html" class="external-link">as.data.frame</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/lapply.html" class="external-link">replicate</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">soltrms_final</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="op">-</span><span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  <span class="va">soltrms_final</span></span>
<span><span class="op">)</span> <span class="op">)</span></span></code></pre></div>
<pre><code>  X1 X14 X5 X20 X6 X3
1 -1  -1 -1  -1 -1 -1
2  0   0  0   0  0  0
3  1   1  1   1  1  1</code></pre>
<p>Then <code><a href="../reference/pred-projection.html">proj_linpred()</a></code> can calculate the linear
predictors<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a> for all new observations from
<code>dat_gauss_new</code>. Depending on argument
<code>integrated</code>, these linear predictors can be averaged across
the projected draws (within each new observation). For instance, the
following computes the expected values of the new observations’
predictive distributions:<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a></p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj_linpred</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pred-projection.html">proj_linpred</a></span><span class="op">(</span><span class="va">prj</span>, newdata <span class="op">=</span> <span class="va">dat_gauss_new</span>, integrated <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="va">dat_gauss_new</span>, linpred <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">prj_linpred</span><span class="op">$</span><span class="va">pred</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code>  X1 X14 X5 X20 X6 X3     linpred
1 -1  -1 -1  -1 -1 -1  0.50053930
2  0   0  0   0  0  0  0.04160798
3  1   1  1   1  1  1 -0.41732334</code></pre>
<p>If <code>dat_gauss_new</code> also contained response values (i.e.,
<code>y</code> values in this example), then <code><a href="../reference/pred-projection.html">proj_linpred()</a></code>
would also evaluate the log predictive density at these.</p>
<p>With <code><a href="../reference/pred-projection.html">proj_predict()</a></code>, we can obtain draws from predictive
distributions based on the final submodel. In contrast to
<code>proj_linpred(&lt;...&gt;, integrated = FALSE)</code>, this
encompasses not only the uncertainty arising from parameter estimation,
but also the uncertainty arising from the observational (or “sampling”)
model for the response.<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a> This is useful for what is usually termed a
posterior predictive check (PPC), but would have to be termed something
like a posterior-projection predictive check (PPPC) here:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">prj_predict</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pred-projection.html">proj_predict</a></span><span class="op">(</span><span class="va">prj</span>, .seed <span class="op">=</span> <span class="fl">762805</span><span class="op">)</span></span>
<span><span class="co"># Using the 'bayesplot' package:</span></span>
<span><span class="fu"><a href="https://mc-stan.org/bayesplot/reference/PPC-distributions.html" class="external-link">ppc_dens_overlay</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">dat_gauss</span><span class="op">$</span><span class="va">y</span>, yrep <span class="op">=</span> <span class="va">prj_predict</span>, alpha <span class="op">=</span> <span class="fl">0.9</span>, bw <span class="op">=</span> <span class="st">"SJ"</span><span class="op">)</span></span></code></pre></div>
<p><img src="projpred_files/figure-html/unnamed-chunk-22-1.png" width="60%" style="display: block; margin: auto;"></p>
<p>This PPPC shows that our final projection is able to generate
predictions similar to the observed response values, which indicates
that this model is reasonable, at least in this regard.</p>
<!-- ## Teardown / clean-up -->
<!-- Finally, we clean up everything we have set up for the parallelization of the projection. This may not always be necessary, but sometimes it is and apart from that, it is simply good practice: -->
<!-- ```{r} -->
<!-- if (!identical(.Platform$OS.type, "windows")) { -->
<!--   stopImplicitCluster() -->
<!--   registerDoSEQ() -->
<!--   options(trigger_default) -->
<!-- } -->
<!-- ``` -->
</div>
</div>
<div class="section level2">
<h2 id="modtypes">Supported types of models<a class="anchor" aria-label="anchor" href="#modtypes"></a>
</h2>
<p>In principle, the projection predictive variable selection requires
only little information about the form of the reference model. Although
many aspects of the reference model coincide with those from the
submodels if a “typical” reference model object is used, this does not
need to be the case if a “custom” reference model object is used (see
section <a href="#refmod">“Reference model”</a> above for the definition
of “typical” and “custom” reference model objects). This explains why in
general, the following remarks refer to the submodels and not to the
reference model.</p>
<p>Apart from the <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian()</a></code> response family used in this
vignette, <strong>projpred</strong> also supports the
<code><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial()</a></code><a href="#fn8" class="footnote-ref" id="fnref8"><sup>8</sup></a> and the <code><a href="https://rdrr.io/r/stats/family.html" class="external-link">poisson()</a></code> family. On
the side of the predictors, <strong>projpred</strong> not only supports
linear main effects as shown in this vignette, but also interactions,
multilevel<a href="#fn9" class="footnote-ref" id="fnref9"><sup>9</sup></a>, and—as an experimental feature—additive<a href="#fn10" class="footnote-ref" id="fnref10"><sup>10</sup></a>
terms.</p>
<p>Transferring this vignette (which employs a “typical” reference
model) to such more complex problems is straightforward: Basically, only
the code for fitting the reference model via <strong>rstanarm</strong>
or <strong>brms</strong> needs to be adapted. The
<strong>projpred</strong> code stays almost the same. Only note that in
case of multilevel or additive reference models,
<!-- the parallelization of the projection is not recommended and that -->
some <strong>projpred</strong> functions then have slightly different
options for a few arguments. See the documentation for details.</p>
<p>For example, to apply <strong>projpred</strong> to the
<code>VerbAgg</code> dataset from the <strong>lme4</strong> package, a
corresponding multilevel reference model for the binary response
<code>r2</code> could be created by the following code:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"VerbAgg"</span>, package <span class="op">=</span> <span class="st">"lme4"</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_glmer.html" class="external-link">stan_glmer</a></span><span class="op">(</span></span>
<span>  <span class="va">r2</span> <span class="op">~</span> <span class="va">btype</span> <span class="op">+</span> <span class="va">situ</span> <span class="op">+</span> <span class="va">mode</span> <span class="op">+</span> <span class="op">(</span><span class="va">btype</span> <span class="op">+</span> <span class="va">situ</span> <span class="op">+</span> <span class="va">mode</span> <span class="op">|</span> <span class="va">id</span><span class="op">)</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">VerbAgg</span>,</span>
<span>  seed <span class="op">=</span> <span class="fl">82616169</span>, QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>As an example for an additive (non-multilevel) reference model,
consider the <code>lasrosas.corn</code> dataset from the
<strong>agridat</strong> package. A corresponding reference model for
the continuous response <code>yield</code> could be created by the
following code (note that <code>pp_check(refm_fit)</code> gives a bad
PPC in this case, so there’s still room for improvement):</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"lasrosas.corn"</span>, package <span class="op">=</span> <span class="st">"agridat"</span><span class="op">)</span></span>
<span><span class="co"># Convert `year` to a `factor` (this could also be solved by using</span></span>
<span><span class="co"># `factor(year)` in the formula, but we avoid that here to put more emphasis on</span></span>
<span><span class="co"># the demonstration of the smooth term):</span></span>
<span><span class="va">lasrosas.corn</span><span class="op">$</span><span class="va">year</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">as.factor</a></span><span class="op">(</span><span class="va">lasrosas.corn</span><span class="op">$</span><span class="va">year</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_gamm4.html" class="external-link">stan_gamm4</a></span><span class="op">(</span></span>
<span>  <span class="va">yield</span> <span class="op">~</span> <span class="va">year</span> <span class="op">+</span> <span class="va">topo</span> <span class="op">+</span> <span class="fu">t2</span><span class="op">(</span><span class="va">nitro</span>, <span class="va">bv</span><span class="op">)</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">gaussian</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">lasrosas.corn</span>,</span>
<span>  seed <span class="op">=</span> <span class="fl">4919670</span>, QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>As an example for an additive multilevel reference model, consider
the <code>gumpertz.pepper</code> dataset from the
<strong>agridat</strong> package. A corresponding reference model for
the binary response <code>disease</code> could be created by the
following code:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="st">"gumpertz.pepper"</span>, package <span class="op">=</span> <span class="st">"agridat"</span><span class="op">)</span></span>
<span><span class="va">refm_fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://mc-stan.org/rstanarm/reference/stan_gamm4.html" class="external-link">stan_gamm4</a></span><span class="op">(</span></span>
<span>  <span class="va">disease</span> <span class="op">~</span> <span class="va">field</span> <span class="op">+</span> <span class="va">leaf</span> <span class="op">+</span> <span class="fu">s</span><span class="op">(</span><span class="va">water</span><span class="op">)</span>,</span>
<span>  random <span class="op">=</span> <span class="op">~</span> <span class="op">(</span><span class="fl">1</span> <span class="op">|</span> <span class="va">row</span><span class="op">)</span> <span class="op">+</span> <span class="op">(</span><span class="fl">1</span> <span class="op">|</span> <span class="va">quadrat</span><span class="op">)</span>,</span>
<span>  family <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/family.html" class="external-link">binomial</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  data <span class="op">=</span> <span class="va">gumpertz.pepper</span>,</span>
<span>  seed <span class="op">=</span> <span class="fl">14209013</span>, QR <span class="op">=</span> <span class="cn">TRUE</span>, refresh <span class="op">=</span> <span class="fl">0</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level2">
<h2 id="troubleshooting">Troubleshooting<a class="anchor" aria-label="anchor" href="#troubleshooting"></a>
</h2>
<p>Sometimes, the ordering of the predictor terms in the solution path
makes sense, but for increasing submodel size, the performance measures
of the submodels do not approach that of the reference model. There are
different reasons that can explain this behavior (the following list
might not be exhaustive, though):</p>
<ol style="list-style-type: decimal">
<li>The reference model’s posterior may be so wide that the default
<code>ndraws_pred</code> could be too small. Usually, this comes in
combination with a difference in predictive performance which is
comparatively small. Increasing <code>ndraws_pred</code> should help,
but it also increases the computational cost. Re-fitting the reference
model and thereby ensuring a narrower posterior (usually by employing a
stronger sparsifying prior) should have a similar effect.</li>
<li>For non-Gaussian models, the discrepancy may be due to the fact that
the penalized iteratively reweighted least squares (PIRLS) algorithm
might have convergence issues <span class="citation">(<a href="#ref-catalina_latent_2021" role="doc-biblioref">Catalina, Bürkner,
and Vehtari 2021</a>)</span>. In this case, the latent-space approach by
<span class="citation">Catalina, Bürkner, and Vehtari (<a href="#ref-catalina_latent_2021" role="doc-biblioref">2021</a>)</span>
might help.</li>
<li>If you are using <code><a href="../reference/varsel.html">varsel()</a></code>, then the lack of the CV in
<code><a href="../reference/varsel.html">varsel()</a></code> may lead to overconfident and overfitted results.
In this case, try running <code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> instead of
<code><a href="../reference/varsel.html">varsel()</a></code> (which you should in any case for your final
results).</li>
</ol>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-catalina_projection_2022" class="csl-entry">
Catalina, Alejandro, Paul-Christian Bürkner, and Aki Vehtari. 2022.
<span>“Projection Predictive Inference for Generalized Linear and
Additive Multilevel Models.”</span> In <em>Proceedings of
<span>The</span> 25th <span>International Conference</span> on
<span>Artificial Intelligence</span> and <span>Statistics</span></em>,
edited by Gustau Camps-Valls, Francisco J. R. Ruiz, and Isabel Valera,
151:4446–61. Proceedings of <span>Machine Learning Research</span>.
<span>PMLR</span>. <a href="https://proceedings.mlr.press/v151/catalina22a.html" class="external-link">https://proceedings.mlr.press/v151/catalina22a.html</a>.
</div>
<div id="ref-catalina_latent_2021" class="csl-entry">
Catalina, Alejandro, Paul Bürkner, and Aki Vehtari. 2021. <span>“Latent
Space Projection Predictive Inference.”</span> <span>arXiv</span>. <a href="https://doi.org/10.48550/arXiv.2109.04702" class="external-link">https://doi.org/10.48550/arXiv.2109.04702</a>.
</div>
<div id="ref-dupuis_variable_2003" class="csl-entry">
Dupuis, Jérome A., and Christian P. Robert. 2003. <span>“Variable
Selection in Qualitative Models via an Entropic Explanatory
Power.”</span> <em>Journal of Statistical Planning and Inference</em>
111 (1–2): 77–94. <a href="https://doi.org/10.1016/S0378-3758(02)00286-0" class="external-link">https://doi.org/10.1016/S0378-3758(02)00286-0</a>.
</div>
<div id="ref-goutis_model_1998" class="csl-entry">
Goutis, Constantinos, and Christian P. Robert. 1998. <span>“Model Choice
in Generalised Linear Models: <span>A Bayesian</span> Approach via
<span>Kullback-Leibler</span> Projections.”</span> <em>Biometrika</em>
85 (1): 29–37.
</div>
<div id="ref-piironen_projective_2020" class="csl-entry">
Piironen, Juho, Markus Paasiniemi, and Aki Vehtari. 2020.
<span>“Projective Inference in High-Dimensional Problems:
<span>Prediction</span> and Feature Selection.”</span> <em>Electronic
Journal of Statistics</em> 14 (1): 2155–97. <a href="https://doi.org/10.1214/20-EJS1711" class="external-link">https://doi.org/10.1214/20-EJS1711</a>.
</div>
<div id="ref-piironen_comparison_2017" class="csl-entry">
Piironen, Juho, and Aki Vehtari. 2017a. <span>“Comparison of
<span>Bayesian</span> Predictive Methods for Model Selection.”</span>
<em>Statistics and Computing</em> 27 (3): 711–35. <a href="https://doi.org/10.1007/s11222-016-9649-y" class="external-link">https://doi.org/10.1007/s11222-016-9649-y</a>.
</div>
<div id="ref-piironen_hyperprior_2017" class="csl-entry">
———. 2017b. <span>“On the Hyperprior Choice for the Global Shrinkage
Parameter in the Horseshoe Prior.”</span> In <em>Proceedings of the 20th
<span>International Conference</span> on <span>Artificial
Intelligence</span> and <span>Statistics</span></em>, edited by Aarti
Singh and Jerry Zhu, 54:905–13. Proceedings of <span>Machine Learning
Research</span>. <span>PMLR</span>. <a href="https://proceedings.mlr.press/v54/piironen17a.html" class="external-link">https://proceedings.mlr.press/v54/piironen17a.html</a>.
</div>
<div id="ref-piironen_sparsity_2017" class="csl-entry">
———. 2017c. <span>“Sparsity Information and Regularization in the
Horseshoe and Other Shrinkage Priors.”</span> <em>Electronic Journal of
Statistics</em> 11 (2): 5018–51. <a href="https://doi.org/10.1214/17-EJS1337SI" class="external-link">https://doi.org/10.1214/17-EJS1337SI</a>.
</div>
</div>
</div>
<div class="footnotes footnotes-end-of-document">
<hr>
<ol>
<li id="fn1"><p>The citation information can be accessed offline by
typing <code>print(citation("projpred"), bibtex = TRUE)</code> within
R.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>We will cover custom reference models more deeply in a
future vignette.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>More generally, the number of chains is split up as
evenly as possible among the number of CPU cores.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p>During the forward search, the reference model has
already been projected onto all candidate models (this was where
arguments <code>ndraws</code> and <code>nclusters</code> of
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> came into play). During the evaluation of the
submodels along the solution path, the reference model has already been
projected onto those submodels (this was where arguments
<code>ndraws_pred</code> and <code>nclusters_pred</code> of
<code><a href="../reference/cv_varsel.html">cv_varsel()</a></code> came into play). In principle, one could use
the results from the evaluation part for post-selection inference, but
due to a bug in the current implementation (see GitHub issue #168), we
currently have to project once again.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
<li id="fn5"><p><code><a href="../reference/pred-projection.html">proj_linpred()</a></code> can also transform the
linear predictor to response scale, but here, this is the same as the
linear predictor scale (because of the identity link function).<a href="#fnref5" class="footnote-back">↩︎</a></p></li>
<li id="fn6"><p>Beware that this statement is correct here because of
the Gaussian family with the identity link function. For other families
(which usually come in combination with a different link function), one
would typically have to use <code>transform = TRUE</code> in order to
make this statement correct.<a href="#fnref6" class="footnote-back">↩︎</a></p></li>
<li id="fn7"><p>In case of the Gaussian family we are using here, the
uncertainty arising from the observational model is the uncertainty due
to the residual standard deviation.<a href="#fnref7" class="footnote-back">↩︎</a></p></li>
<li id="fn8"><p>Via <code><a href="https://rdrr.io/pkg/brms/man/get_refmodel.brmsfit.html" class="external-link">brms::get_refmodel.brmsfit()</a></code>, the
<code><a href="https://rdrr.io/pkg/brms/man/brmsfamily.html" class="external-link">brms::bernoulli()</a></code> family is supported as well.<a href="#fnref8" class="footnote-back">↩︎</a></p></li>
<li id="fn9"><p>Multilevel models are also known as
<em>hierarchical</em> models or models with <em>partially pooled</em>,
<em>group-level</em>, or—in frequentist terms—<em>random</em> effects.<a href="#fnref9" class="footnote-back">↩︎</a></p></li>
<li id="fn10"><p>Additive terms are also known as <em>smooth</em>
terms.<a href="#fnref10" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Juho Piironen, Markus Paasiniemi, Alejandro Catalina, Frank Weber, Aki Vehtari.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
