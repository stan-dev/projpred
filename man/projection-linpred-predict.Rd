% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods.R
\name{projection-linpred-predict}
\alias{projection-linpred-predict}
\alias{proj_linpred}
\alias{proj_predict}
\title{Predictions from a submodel (after projection)}
\usage{
proj_linpred(
  object,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  filter_nterms = NULL,
  transform = FALSE,
  integrated = FALSE,
  ...
)

proj_predict(
  object,
  newdata = NULL,
  offsetnew = NULL,
  weightsnew = NULL,
  filter_nterms = NULL,
  nresample_clusters = 1000,
  .seed = NULL,
  ...
)
}
\arguments{
\item{object}{Either an object returned by \code{\link[=project]{project()}} or alternatively any
object that can be passed to argument \code{object} of \code{\link[=project]{project()}}.}

\item{newdata}{Passed to argument \code{newdata} of the reference model's
\code{extract_model_data} function (see \code{\link[=init_refmodel]{init_refmodel()}}). Provides the
predictor (and possibly also the response) data for the new (or old)
observations.}

\item{offsetnew}{Passed to argument \code{orhs} of the reference model's
\code{extract_model_data} function (see \code{\link[=init_refmodel]{init_refmodel()}}). Used to get the
offsets for the new (or old) observations.}

\item{weightsnew}{Passed to argument \code{wrhs} of the reference model's
\code{extract_model_data} function (see \code{\link[=init_refmodel]{init_refmodel()}}). Used to get the
weights for the new (or old) observations.}

\item{filter_nterms}{Only applies if \code{object} is an object returned by
\code{\link[=project]{project()}}. In that case, \code{filter_nterms} can be used to filter \code{object}
for only those elements (submodels) with a number of solution terms in
\code{filter_nterms}. Therefore, needs to be a numeric vector or \code{NULL}. If
\code{NULL}, use all submodels.}

\item{transform}{For \code{\link[=proj_linpred]{proj_linpred()}} only. A single logical value indicating
whether the linear predictor should be transformed using the inverse-link
function (\code{TRUE}) or not (\code{FALSE}).}

\item{integrated}{For \code{\link[=proj_linpred]{proj_linpred()}} only. A single logical value
indicating whether the output should be averaged over the projected
posterior draws (\code{TRUE}) or not (\code{FALSE}).}

\item{...}{Additional arguments passed to \code{\link[=project]{project()}} if \code{object} is not
already an object returned by \code{\link[=project]{project()}}.}

\item{nresample_clusters}{For \code{\link[=proj_predict]{proj_predict()}} with clustered projection
only. Number of draws to return from the predictive distribution of the
projection. Not to be confused with argument \code{nclusters} of \code{\link[=project]{project()}}:
\code{nresample_clusters} gives the number of draws (\emph{with} replacement) from
the set of clustered posterior draws after projection (as determined by
argument \code{nclusters} of \code{\link[=project]{project()}}).}

\item{.seed}{For \code{\link[=proj_predict]{proj_predict()}} only. Pseudorandom number generation (PRNG)
seed by which the same results can be obtained again if needed. If \code{NULL},
no seed is set and therefore, the results are not reproducible. See
\code{\link[=set.seed]{set.seed()}} for details. Here, this seed is used for drawing from the
predictive distribution of the submodel(s) onto which the reference model
was projected. If a clustered projection was performed, \code{.seed} is also
used for drawing from the set of the projected clusters of posterior draws
(see argument \code{nresample_clusters}).}
}
\value{
If the prediction is done for one submodel only (i.e., \code{nterms} has
length one or \code{solution_terms} is specified):
\itemize{
\item \code{\link[=proj_linpred]{proj_linpred()}} returns a \code{list} with elements \code{pred} (predictions) and
\code{lpd} (log predictive densities). Each of these two elements is a \eqn{S
  \times N}{S x N} matrix.
\item \code{\link[=proj_predict]{proj_predict()}} returns a \eqn{S \times N}{S x N} matrix of predictions.
}

Thereby, \eqn{S} denotes the number of (possibly clustered) projected
posterior draws and \eqn{N} denotes the number of observations.

If the prediction is done for more than one submodel, the output from above
is returned for each submodel, giving a named \code{list} with one element for
each submodel (the names of this \code{list} being the numbers of solutions
terms of the submodels when counting the intercept, too).
}
\description{
\code{\link[=proj_linpred]{proj_linpred()}} gives draws of the linear predictor (possibly transformed to
response scale) of a submodel (after projecting the reference model onto it).
\code{\link[=proj_predict]{proj_predict()}} draws from the predictive distribution of such a submodel.
If the projection has not been performed, both functions also perform the
projection. Both functions can also handle multiple submodels at once (if the
input object is of class \code{vsel}).
}
\examples{
if (requireNamespace("rstanarm", quietly = TRUE)) {
  # Data:
  dat_gauss <- data.frame(y = df_gaussian$y, df_gaussian$x)

  # The "stanreg" fit which will be used as the reference model:
  fit <- rstanarm::stan_glm(
    y ~ X1 + X2 + X3 + X4 + X5, family = gaussian(), data = dat_gauss,
    QR = TRUE, chains = 2, iter = 500, refresh = 0, seed = 9876
  )

  # Projection onto an arbitrary combination of predictor terms (with a small
  # value for `nclusters`, but only for the sake of speed in this example;
  # this is not recommended in general):
  prj <- project(fit, solution_terms = c("X1", "X3", "X5"), nclusters = 10,
                 seed = 9182)

  # Predictions (at the training points) from the projected submodel:
  prjl <- proj_linpred(prj)
  prjp <- proj_predict(prj, .seed = 7364)
}

}
